<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>http总结 | Lzs-Study</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog/img/common/favicon.ico">
    <script language="javascript" type="text/javascript" src="https://cdn.staticfile.org/jquery/1.7.2/jquery.min.js"></script>
    <script language="javascript" type="text/javascript" src="/blog/js/BaiduStatistics.js"></script>
    <meta name="description" content="一起来学前端吧 →">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/blog/assets/css/0.styles.144acb66.css" as="style"><link rel="preload" href="/blog/assets/js/app.41200af2.js" as="script"><link rel="preload" href="/blog/assets/js/3.dc4313c1.js" as="script"><link rel="preload" href="/blog/assets/js/1.6ffa0505.js" as="script"><link rel="preload" href="/blog/assets/js/70.67374505.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.1e8cd5f5.js"><link rel="prefetch" href="/blog/assets/js/100.94ca1c8e.js"><link rel="prefetch" href="/blog/assets/js/101.2210302d.js"><link rel="prefetch" href="/blog/assets/js/102.9956bc8d.js"><link rel="prefetch" href="/blog/assets/js/103.3027e683.js"><link rel="prefetch" href="/blog/assets/js/104.c2d537f1.js"><link rel="prefetch" href="/blog/assets/js/105.27e5e384.js"><link rel="prefetch" href="/blog/assets/js/11.4665c2a9.js"><link rel="prefetch" href="/blog/assets/js/12.25e51219.js"><link rel="prefetch" href="/blog/assets/js/13.2f465012.js"><link rel="prefetch" href="/blog/assets/js/14.ad186ee9.js"><link rel="prefetch" href="/blog/assets/js/15.5084f789.js"><link rel="prefetch" href="/blog/assets/js/16.316fb22e.js"><link rel="prefetch" href="/blog/assets/js/17.6a9ba9b0.js"><link rel="prefetch" href="/blog/assets/js/18.55ef468a.js"><link rel="prefetch" href="/blog/assets/js/19.1bdd4438.js"><link rel="prefetch" href="/blog/assets/js/20.21896509.js"><link rel="prefetch" href="/blog/assets/js/21.a23507d1.js"><link rel="prefetch" href="/blog/assets/js/22.886b87a8.js"><link rel="prefetch" href="/blog/assets/js/23.c9b79539.js"><link rel="prefetch" href="/blog/assets/js/24.b47c940e.js"><link rel="prefetch" href="/blog/assets/js/25.10b99ce8.js"><link rel="prefetch" href="/blog/assets/js/26.da780aaa.js"><link rel="prefetch" href="/blog/assets/js/27.432494d5.js"><link rel="prefetch" href="/blog/assets/js/28.2bbcf00a.js"><link rel="prefetch" href="/blog/assets/js/29.dd151750.js"><link rel="prefetch" href="/blog/assets/js/30.bb8ecc3a.js"><link rel="prefetch" href="/blog/assets/js/31.010ffd1d.js"><link rel="prefetch" href="/blog/assets/js/32.1f605968.js"><link rel="prefetch" href="/blog/assets/js/33.d1273b4c.js"><link rel="prefetch" href="/blog/assets/js/34.1400a36f.js"><link rel="prefetch" href="/blog/assets/js/35.519ccb29.js"><link rel="prefetch" href="/blog/assets/js/36.fd211c30.js"><link rel="prefetch" href="/blog/assets/js/37.607d53a2.js"><link rel="prefetch" href="/blog/assets/js/38.16ea1b1c.js"><link rel="prefetch" href="/blog/assets/js/39.8208f22a.js"><link rel="prefetch" href="/blog/assets/js/4.90190d4e.js"><link rel="prefetch" href="/blog/assets/js/40.f1deee61.js"><link rel="prefetch" href="/blog/assets/js/41.5a9339ad.js"><link rel="prefetch" href="/blog/assets/js/42.3c799a4f.js"><link rel="prefetch" href="/blog/assets/js/43.a83f8cfa.js"><link rel="prefetch" href="/blog/assets/js/44.f729ac0a.js"><link rel="prefetch" href="/blog/assets/js/45.23cc8577.js"><link rel="prefetch" href="/blog/assets/js/46.b41c442a.js"><link rel="prefetch" href="/blog/assets/js/47.d5392e73.js"><link rel="prefetch" href="/blog/assets/js/48.d99d6c14.js"><link rel="prefetch" href="/blog/assets/js/49.43813992.js"><link rel="prefetch" href="/blog/assets/js/5.5d49b1e5.js"><link rel="prefetch" href="/blog/assets/js/50.ef0f1a7f.js"><link rel="prefetch" href="/blog/assets/js/51.696e5dfd.js"><link rel="prefetch" href="/blog/assets/js/52.47b401a2.js"><link rel="prefetch" href="/blog/assets/js/53.8fe25942.js"><link rel="prefetch" href="/blog/assets/js/54.baa66dc8.js"><link rel="prefetch" href="/blog/assets/js/55.b37b55ab.js"><link rel="prefetch" href="/blog/assets/js/56.57bb733e.js"><link rel="prefetch" href="/blog/assets/js/57.ef57d52d.js"><link rel="prefetch" href="/blog/assets/js/58.29307055.js"><link rel="prefetch" href="/blog/assets/js/59.80667b86.js"><link rel="prefetch" href="/blog/assets/js/6.d629b6e8.js"><link rel="prefetch" href="/blog/assets/js/60.e1be2e00.js"><link rel="prefetch" href="/blog/assets/js/61.8e4f495a.js"><link rel="prefetch" href="/blog/assets/js/62.7ddecd00.js"><link rel="prefetch" href="/blog/assets/js/63.71747c39.js"><link rel="prefetch" href="/blog/assets/js/64.ac3dcd64.js"><link rel="prefetch" href="/blog/assets/js/65.2b0d3ec5.js"><link rel="prefetch" href="/blog/assets/js/66.0ddb735b.js"><link rel="prefetch" href="/blog/assets/js/67.959fbce8.js"><link rel="prefetch" href="/blog/assets/js/68.fc621fdf.js"><link rel="prefetch" href="/blog/assets/js/69.f4aedafb.js"><link rel="prefetch" href="/blog/assets/js/7.8a501913.js"><link rel="prefetch" href="/blog/assets/js/71.4c8ffeff.js"><link rel="prefetch" href="/blog/assets/js/72.ed20068e.js"><link rel="prefetch" href="/blog/assets/js/73.73d69187.js"><link rel="prefetch" href="/blog/assets/js/74.ae19e028.js"><link rel="prefetch" href="/blog/assets/js/75.68fd7ddc.js"><link rel="prefetch" href="/blog/assets/js/76.3034e47f.js"><link rel="prefetch" href="/blog/assets/js/77.3f9522ac.js"><link rel="prefetch" href="/blog/assets/js/78.11875eab.js"><link rel="prefetch" href="/blog/assets/js/79.ea437ea4.js"><link rel="prefetch" href="/blog/assets/js/8.a121115a.js"><link rel="prefetch" href="/blog/assets/js/80.8299c6f6.js"><link rel="prefetch" href="/blog/assets/js/81.6c45aade.js"><link rel="prefetch" href="/blog/assets/js/82.834bf390.js"><link rel="prefetch" href="/blog/assets/js/83.c853ef36.js"><link rel="prefetch" href="/blog/assets/js/84.9cb0f01a.js"><link rel="prefetch" href="/blog/assets/js/85.3d9c51fc.js"><link rel="prefetch" href="/blog/assets/js/86.7e33f84a.js"><link rel="prefetch" href="/blog/assets/js/87.28cc1dc7.js"><link rel="prefetch" href="/blog/assets/js/88.5bf52d81.js"><link rel="prefetch" href="/blog/assets/js/89.63437ceb.js"><link rel="prefetch" href="/blog/assets/js/9.95109948.js"><link rel="prefetch" href="/blog/assets/js/90.575579a6.js"><link rel="prefetch" href="/blog/assets/js/91.864b1d09.js"><link rel="prefetch" href="/blog/assets/js/92.9f58d020.js"><link rel="prefetch" href="/blog/assets/js/93.164272e4.js"><link rel="prefetch" href="/blog/assets/js/94.5960b1db.js"><link rel="prefetch" href="/blog/assets/js/95.1feaebc8.js"><link rel="prefetch" href="/blog/assets/js/96.b610e95c.js"><link rel="prefetch" href="/blog/assets/js/97.3fc0f92b.js"><link rel="prefetch" href="/blog/assets/js/98.bc62eb74.js"><link rel="prefetch" href="/blog/assets/js/99.9be50f27.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.144acb66.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>Lzs-Study</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>一起来学前端吧 →</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>Lzs</span>
            
          <span data-v-4e82dffc>2022 - </span>
          2023
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/common/logo.jpg" alt="Lzs-Study" class="logo"> <span class="site-name">Lzs-Study</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      技术分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/leetcode/" class="nav-link"><i class="undefined"></i>
  leetcode
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/shousi/" class="nav-link"><i class="undefined"></i>
  shousi
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/ES6/" class="nav-link"><i class="undefined"></i>
  ES6
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/git/" class="nav-link"><i class="undefined"></i>
  git
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/HTML+CSS/" class="nav-link"><i class="undefined"></i>
  HTML+CSS
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/JavaScript高级/" class="nav-link"><i class="undefined"></i>
  JavaScript高级
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/JavaScript基础/" class="nav-link"><i class="undefined"></i>
  JavaScript基础
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/Node/" class="nav-link"><i class="undefined"></i>
  Node
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/Note/" class="nav-link"><i class="undefined"></i>
  Note
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/vue/" class="nav-link"><i class="undefined"></i>
  vue
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/react/" class="nav-link"><i class="undefined"></i>
  react
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/chat/" class="nav-link"><i class="undefined"></i>
  chat
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/博客/" class="nav-link"><i class="undefined"></i>
  博客
</a></li></ul></div></div><div class="nav-item"><a href="/blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-suggestion"></i>
      文章目录
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/blogs/frontEnd/" class="nav-link router-link-active"><i class="undefined"></i>
  从0学前端
</a></li><li class="dropdown-item"><!----> <a href="/blog/blogs/algorithm.html" class="nav-link"><i class="undefined"></i>
  算法学习
</a></li><li class="dropdown-item"><!----> <a href="/blog/chat/" class="nav-link"><i class="undefined"></i>
  心情随笔
</a></li><li class="dropdown-item"><!----> <a href="/blog/docs/" class="nav-link"><i class="undefined"></i>
  博客搭建
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系lzs
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/innovation66" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/3224192550974200" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-juejin"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/blog/img/common/avatar.jpg" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    Lzs
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>94</h3> <h6 data-v-828910c6>文章</h6></div> <div data-v-828910c6><h3 data-v-828910c6>113</h3> <h6 data-v-828910c6>标签</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="iconfont reco-home"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      技术分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/leetcode/" class="nav-link"><i class="undefined"></i>
  leetcode
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/shousi/" class="nav-link"><i class="undefined"></i>
  shousi
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/ES6/" class="nav-link"><i class="undefined"></i>
  ES6
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/git/" class="nav-link"><i class="undefined"></i>
  git
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/HTML+CSS/" class="nav-link"><i class="undefined"></i>
  HTML+CSS
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/JavaScript高级/" class="nav-link"><i class="undefined"></i>
  JavaScript高级
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/JavaScript基础/" class="nav-link"><i class="undefined"></i>
  JavaScript基础
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/Node/" class="nav-link"><i class="undefined"></i>
  Node
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/Note/" class="nav-link"><i class="undefined"></i>
  Note
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/vue/" class="nav-link"><i class="undefined"></i>
  vue
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/react/" class="nav-link"><i class="undefined"></i>
  react
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/chat/" class="nav-link"><i class="undefined"></i>
  chat
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/博客/" class="nav-link"><i class="undefined"></i>
  博客
</a></li></ul></div></div><div class="nav-item"><a href="/blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-suggestion"></i>
      文章目录
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/blogs/frontEnd/" class="nav-link router-link-active"><i class="undefined"></i>
  从0学前端
</a></li><li class="dropdown-item"><!----> <a href="/blog/blogs/algorithm.html" class="nav-link"><i class="undefined"></i>
  算法学习
</a></li><li class="dropdown-item"><!----> <a href="/blog/chat/" class="nav-link"><i class="undefined"></i>
  心情随笔
</a></li><li class="dropdown-item"><!----> <a href="/blog/docs/" class="nav-link"><i class="undefined"></i>
  博客搭建
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联系lzs
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/innovation66" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/3224192550974200" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-juejin"></i>
  掘金
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><a href="/blog/blogs/frontEnd/" aria-current="page" class="sidebar-link">前端技术学习目录</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端学习网站和软件下载</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML+CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JavaScript高级</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>ECMAScript6~12</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vuejs</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>http总结</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>Lzs</span>
            
          <span data-v-4e82dffc>2022 - </span>
          2023
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">http总结</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>Lzs</span></i> <i class="iconfont reco-date" data-v-1ff7123e><span data-v-1ff7123e>2023/3/10</span></i> <!----> <i class="tags iconfont reco-tag" data-v-1ff7123e><span class="tag-item" data-v-1ff7123e>http</span></i></div></div> <div class="theme-reco-content content__default"><h2 id="_001-http-报文结构是怎样的"><a href="#_001-http-报文结构是怎样的" class="header-anchor">#</a> 001. HTTP 报文结构是怎样的？</h2> <p>对于 TCP 而言，在传输的时候分为两个部分:<strong>TCP 头</strong>和<strong>数据部分</strong>。</p> <p>而 HTTP 类似，也是<code>header + body</code>的结构，具体而言:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>起始行 + 头部 + 空行 + 实体
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>由于 http <code>请求报文</code>和<code>响应报文</code>是有一定区别，因此我们分开介绍。</p> <h3 id="起始行"><a href="#起始行" class="header-anchor">#</a> 起始行</h3> <p>对于请求报文来说，起始行类似下面这样:</p> <div class="language-arduino line-numbers-mode"><pre class="language-arduino"><code>GET <span class="token operator">/</span><span class="token builtin">home</span> HTTP<span class="token operator">/</span><span class="token number">1.1</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>也就是<strong>方法 + 路径 + http 版本</strong>。</p> <p>对于响应报文来说，起始行一般张这个样:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>HTTP/1.1 200 OK
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>响应报文的起始行也叫做<code>状态行</code>。由<strong>http 版本、状态码和原因</strong>三部分组成。</p> <p>值得注意的是，在起始行中，每两个部分之间用<strong>空格</strong>隔开，最后一个部分后面应该接一个<strong>换行</strong>，严格遵循<code>ABNF</code>语法规范。</p> <h3 id="头部"><a href="#头部" class="header-anchor">#</a> 头部</h3> <p>展示一下请求头和响应头在报文中的位置:</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd6012e2fc88~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd62af8538e4~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <p>不管是请求头还是响应头，其中的字段是相当多的，而且牵扯到<code>http</code>非常多的特性，这里就不一一列举的，重点看看这些头部字段的格式：</p> <ul><li><ol><li>字段名不区分大小写</li></ol></li> <li><ol><li>字段名不允许出现空格，不可以出现下划线<code>_</code></li></ol></li> <li><ol><li>字段名后面必须<strong>紧接着<code>:</code></strong></li></ol></li></ul> <h3 id="空行"><a href="#空行" class="header-anchor">#</a> 空行</h3> <p>很重要，用来区分开<code>头部</code>和<code>实体</code>。</p> <p>问: 如果说在头部中间故意加一个空行会怎么样？</p> <p>那么空行后的内容全部被视为实体。</p> <h3 id="实体"><a href="#实体" class="header-anchor">#</a> 实体</h3> <p>就是具体的数据了，也就是<code>body</code>部分。请求报文对应<code>请求体</code>, 响应报文对应<code>响应体</code>。</p> <h2 id="_002-如何理解-http-的请求方法"><a href="#_002-如何理解-http-的请求方法" class="header-anchor">#</a> 002. 如何理解 HTTP 的请求方法？</h2> <h3 id="有哪些请求方法"><a href="#有哪些请求方法" class="header-anchor">#</a> 有哪些请求方法？</h3> <p><code>http/1.1</code>规定了以下请求方法(注意，都是大写):</p> <ul><li>GET: 通常用来获取资源</li> <li>HEAD: 获取资源的元信息</li> <li>POST: 提交数据，即上传数据</li> <li>PUT: 修改数据</li> <li>DELETE: 删除资源(几乎用不到)</li> <li>CONNECT: 建立连接隧道，用于代理服务器</li> <li>OPTIONS: 列出可对资源实行的请求方法，用来跨域请求</li> <li>TRACE: 追踪请求-响应的传输路径</li></ul> <h3 id="get-和-post-有什么区别"><a href="#get-和-post-有什么区别" class="header-anchor">#</a> GET 和 POST 有什么区别？</h3> <p>首先最直观的是语义上的区别。</p> <p>而后又有这样一些具体的差别:</p> <ul><li>从<strong>缓存</strong>的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li> <li>从<strong>编码</strong>的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。</li> <li>从<strong>参数</strong>的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li> <li>从<strong>幂等性</strong>的角度，<code>GET</code>是<strong>幂等</strong>的，而<code>POST</code>不是。(<code>幂等</code>表示执行相同的操作，结果也是相同的)</li> <li>从<strong>TCP</strong>的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(<strong>火狐</strong>浏览器除外，它的 POST 请求只发一个 TCP 包)</li></ul> <h2 id="_003-如何理解-uri"><a href="#_003-如何理解-uri" class="header-anchor">#</a> 003: 如何理解 URI？</h2> <p><strong>URI</strong>, 全称为(Uniform Resource Identifier), 也就是<strong>统一资源标识符</strong>，它的作用很简单，就是区分互联网上不同的资源。</p> <p>但是，它并不是我们常说的<code>网址</code>, 网址指的是<code>URL</code>, 实际上<code>URI</code>包含了<code>URN</code>和<code>URL</code>两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。</p> <h3 id="uri-的结构"><a href="#uri-的结构" class="header-anchor">#</a> URI 的结构</h3> <p>URI 真正最完整的结构是这样的。</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd677629b70d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <p>可能你会有疑问，好像跟平时见到的不太一样啊！先别急，我们来一一拆解。</p> <p><strong>scheme</strong> 表示协议名，比如<code>http</code>, <code>https</code>, <code>file</code>等等。后面必须和<code>://</code>连在一起。</p> <p><strong>user:passwd</strong>@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。</p> <p><strong>host:port</strong>表示主机名和端口。</p> <p><strong>path</strong>表示请求路径，标记资源所在位置。</p> <p><strong>query</strong>表示查询参数，为<code>key=val</code>这种形式，多个键值对之间用<code>&amp;</code>隔开。</p> <p><strong>fragment</strong>表示 URI 所定位的资源内的一个<strong>锚点</strong>，浏览器可以根据这个锚点跳转到对应的位置。</p> <p>举个例子:</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code><span class="token key attr-name">https://www.baidu.com/s?wd</span><span class="token punctuation">=</span><span class="token value attr-value">HTTP&amp;rsv_spt=1</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这个 URI 中，<code>https</code>即<code>scheme</code>部分，<code>www.baidu.com</code>为<code>host:port</code>部分（注意，http 和 https 的默认端口分别为 80、443），<code>/s</code>为<code>path</code>部分，而<code>wd=HTTP&amp;rsv_spt=1</code>就是<code>query</code>部分。</p> <h3 id="uri-编码"><a href="#uri-编码" class="header-anchor">#</a> URI 编码</h3> <p>URI 只能使用<code>ASCII</code>, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。</p> <p>因此，URI 引入了<code>编码</code>机制，将所有<strong>非 ASCII 码字符</strong>和<strong>界定符</strong>转为十六进制字节值，然后在前面加个<code>%</code>。</p> <p>如，空格被转义成了<code>%20</code>，<strong>三元</strong>被转义成了<code>%E4%B8%89%E5%85%83</code>。</p> <h2 id="_004-如何理解-http-状态码"><a href="#_004-如何理解-http-状态码" class="header-anchor">#</a> 004: 如何理解 HTTP 状态码？</h2> <p>RFC 规定 HTTP 的状态码为<strong>三位数</strong>，被分为五类:</p> <ul><li><strong>1xx</strong>: 表示目前是协议处理的中间状态，还需要后续操作。</li> <li><strong>2xx</strong>: 表示成功状态。</li> <li><strong>3xx</strong>: 重定向状态，资源位置发生变动，需要重新请求。</li> <li><strong>4xx</strong>: 请求报文有误。</li> <li><strong>5xx</strong>: 服务器端发生错误。</li></ul> <p>接下来就一一分析这里面具体的状态码。</p> <h3 id="_1xx"><a href="#_1xx" class="header-anchor">#</a> 1xx</h3> <p><strong>101 Switching Protocols</strong>。在<code>HTTP</code>升级为<code>WebSocket</code>的时候，如果服务器同意变更，就会发送状态码 101。</p> <h3 id="_2xx"><a href="#_2xx" class="header-anchor">#</a> 2xx</h3> <p><strong>200 OK</strong>是见得最多的成功状态码。通常在响应体中放有数据。</p> <p><strong>204 No Content</strong>含义与 200 相同，但响应头后没有 body 数据。</p> <p><strong>206 Partial Content</strong>顾名思义，表示部分内容，它的使用场景为 HTTP 分块下载和断点续传，当然也会带上相应的响应头字段<code>Content-Range</code>。</p> <h3 id="_3xx"><a href="#_3xx" class="header-anchor">#</a> 3xx</h3> <p><strong>301 Moved Permanently</strong>即永久重定向，对应着<strong>302 Found</strong>，即临时重定向。</p> <p>比如你的网站从 HTTP 升级到了 HTTPS 了，以前的站点再也不用了，应当返回<code>301</code>，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。</p> <p>而如果只是暂时不可用，那么直接返回<code>302</code>即可，和<code>301</code>不同的是，浏览器并不会做缓存优化。</p> <p><strong>304 Not Modified</strong>: 当协商缓存命中时会返回这个状态码。详见<a href="https://link.juejin.cn?target=http%3A%2F%2F47.98.159.95%2Fmy_blog%2Fperform%2F001.html" target="_blank" rel="noopener noreferrer">浏览器缓存<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="_4xx"><a href="#_4xx" class="header-anchor">#</a> 4xx</h3> <p><strong>400 Bad Request</strong>: 开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。</p> <p><strong>403 Forbidden</strong>: 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多，比如法律禁止、信息敏感。</p> <p><strong>404 Not Found</strong>: 资源未找到，表示没在服务器上找到相应的资源。</p> <p><strong>405 Method Not Allowed</strong>: 请求方法不被服务器端允许。</p> <p><strong>406 Not Acceptable</strong>: 资源无法满足客户端的条件。</p> <p><strong>408 Request Timeout</strong>: 服务器等待了太长时间。</p> <p><strong>409 Conflict</strong>: 多个请求发生了冲突。</p> <p><strong>413 Request Entity Too Large</strong>: 请求体的数据过大。</p> <p><strong>414 Request-URI Too Long</strong>: 请求行里的 URI 太大。</p> <p><strong>429 Too Many Request</strong>: 客户端发送的请求过多。</p> <p><strong>431 Request Header Fields Too Large</strong>请求头的字段内容太大。</p> <h3 id="_5xx"><a href="#_5xx" class="header-anchor">#</a> 5xx</h3> <p><strong>500 Internal Server Error</strong>: 仅仅告诉你服务器出错了，出了啥错咱也不知道。</p> <p><strong>501 Not Implemented</strong>: 表示客户端请求的功能还不支持。</p> <p><strong>502 Bad Gateway</strong>: 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。</p> <p><strong>503 Service Unavailable</strong>: 表示服务器当前很忙，暂时无法响应服务。</p> <h2 id="_005-简要概括一下-http-的特点-http-有哪些缺点"><a href="#_005-简要概括一下-http-的特点-http-有哪些缺点" class="header-anchor">#</a> 005: 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</h2> <h3 id="http-特点"><a href="#http-特点" class="header-anchor">#</a> HTTP 特点</h3> <p>HTTP 的特点概括如下:</p> <ol><li>灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</li> <li>可靠传输。HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。</li> <li>请求-应答。也就是<code>一发一收</code>、<code>有来有回</code>， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演<strong>请求方</strong>的角色。</li> <li>无状态。这里的状态是指<strong>通信过程的上下文信息</strong>，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。</li></ol> <h3 id="http-缺点"><a href="#http-缺点" class="header-anchor">#</a> HTTP 缺点</h3> <h4 id="无状态"><a href="#无状态" class="header-anchor">#</a> 无状态</h4> <p>所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的<strong>无状态</strong>。</p> <p>在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。</p> <p>但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。</p> <h4 id="明文传输"><a href="#明文传输" class="header-anchor">#</a> 明文传输</h4> <p>即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。</p> <p>这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。<code>WIFI陷阱</code>就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。</p> <h4 id="队头阻塞问题"><a href="#队头阻塞问题" class="header-anchor">#</a> 队头阻塞问题</h4> <p>当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的<strong>队头阻塞</strong>问题。接下来会有一小节讨论这个问题。</p> <h2 id="_006-对-accept-系列字段了解多少"><a href="#_006-对-accept-系列字段了解多少" class="header-anchor">#</a> 006: 对 Accept 系列字段了解多少？</h2> <p>对于<code>Accept</code>系列字段的介绍分为四个部分: <strong>数据格式</strong>、<strong>压缩方式</strong>、<strong>支持语言</strong>和<strong>字符集</strong>。</p> <h3 id="数据格式"><a href="#数据格式" class="header-anchor">#</a> 数据格式</h3> <p>上一节谈到 HTTP 灵活的特性，它支持非常多的数据格式，那么这么多格式的数据一起到达客户端，客户端怎么知道它的格式呢？</p> <p>当然，最低效的方式是直接猜，有没有更好的方式呢？直接指定可以吗？</p> <p>答案是肯定的。不过首先需要介绍一个标准——<strong>MIME</strong>(Multipurpose Internet Mail Extensions, <strong>多用途互联网邮件扩展</strong>)。它首先用在电子邮件系统中，让邮件可以发任意类型的数据，这对于 HTTP 来说也是通用的。</p> <p>因此，HTTP 从<strong>MIME type</strong>取了一部分来标记报文 body 部分的数据类型，这些类型体现在<code>Content-Type</code>这个字段，当然这是针对于发送端而言，接收端想要收到特定类型的数据，也可以用<code>Accept</code>字段。</p> <p>具体而言，这两个字段的取值可以分为下面几类:</p> <ul><li>text： text/html, text/plain, text/css 等</li> <li>image: image/gif, image/jpeg, image/png 等</li> <li>audio/video: audio/mpeg, video/mp4 等</li> <li>application: application/json, application/javascript, application/pdf, application/octet-stream</li></ul> <h3 id="压缩方式"><a href="#压缩方式" class="header-anchor">#</a> 压缩方式</h3> <p>当然一般这些数据都是会进行编码压缩的，采取什么样的压缩方式就体现在了发送方的<code>Content-Encoding</code>字段上， 同样的，接收什么样的压缩方式体现在了接受方的<code>Accept-Encoding</code>字段上。这个字段的取值有下面几种：</p> <ul><li>gzip: 当今最流行的压缩格式</li> <li>deflate: 另外一种著名的压缩格式</li> <li>br: 一种专门为 HTTP 发明的压缩算法</li></ul> <div class="language-less line-numbers-mode"><pre class="language-less"><code><span class="token comment">// 发送端</span>
<span class="token property">Content-Encoding</span><span class="token punctuation">:</span> gzip
<span class="token comment">// 接收端</span>
<span class="token property">Accept-Encoding</span><span class="token punctuation">:</span> gzip
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="支持语言"><a href="#支持语言" class="header-anchor">#</a> 支持语言</h3> <p>对于发送方而言，还有一个<code>Content-Language</code>字段，在需要实现国际化的方案当中，可以用来指定支持的语言，在接受方对应的字段为<code>Accept-Language</code>。如:</p> <div class="language-less line-numbers-mode"><pre class="language-less"><code><span class="token comment">// 发送端</span>
<span class="token property">Content-Language</span><span class="token punctuation">:</span> zh<span class="token operator">-</span>CN<span class="token punctuation">,</span> zh<span class="token punctuation">,</span> en
<span class="token comment">// 接收端</span>
<span class="token property">Accept-Language</span><span class="token punctuation">:</span> zh<span class="token operator">-</span>CN<span class="token punctuation">,</span> zh<span class="token punctuation">,</span> en
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="字符集"><a href="#字符集" class="header-anchor">#</a> 字符集</h3> <p>最后是一个比较特殊的字段, 在接收端对应为<code>Accept-Charset</code>，指定可以接受的字符集，而在发送端并没有对应的<code>Content-Charset</code>, 而是直接放在了<code>Content-Type</code>中，以<strong>charset</strong>属性指定。如:</p> <div class="language-scss line-numbers-mode"><pre class="language-scss"><code><span class="token comment">// 发送端</span>
<span class="token property">Content-Type</span><span class="token punctuation">:</span> text/html<span class="token punctuation">;</span> charset=utf-8
<span class="token comment">// 接收端</span>
<span class="token property">Accept-Charset</span><span class="token punctuation">:</span> charset=utf-8
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>最后以一张图来总结一下吧:</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd6bb6d09c2d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <h2 id="_007-对于定长和不定长的数据-http-是怎么传输的"><a href="#_007-对于定长和不定长的数据-http-是怎么传输的" class="header-anchor">#</a> 007: 对于定长和不定长的数据，HTTP 是怎么传输的？</h2> <h3 id="定长包体"><a href="#定长包体" class="header-anchor">#</a> 定长包体</h3> <p>对于定长包体而言，发送端在传输的时候一般会带上 <code>Content-Length</code>, 来指明包体的长度。</p> <p>我们用一个<code>nodejs</code>服务器来模拟一下:</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;request&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Content-Type&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;text/plain&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Content-Length&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;helloworld&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8081</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;成功启动&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
复制代码<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>启动后访问: <strong>localhost:8081</strong>。</p> <p>浏览器中显示如下:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>helloworld
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这是长度正确的情况，那不正确的情况是如何处理的呢？</p> <p>我们试着把这个长度设置的小一些:</p> <div class="language-arduino line-numbers-mode"><pre class="language-arduino"><code>res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token char">'Content-Length'</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>重启服务，再次访问，现在浏览器中内容如下:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>hellowor
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>那后面的<code>ld</code>哪里去了呢？实际上在 http 的响应体中直接被截去了。</p> <p>然后我们试着将这个长度设置得大一些:</p> <div class="language-arduino line-numbers-mode"><pre class="language-arduino"><code>res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token char">'Content-Length'</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>此时浏览器显示如下:</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd6f598bea62~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <p>直接无法显示了。可以看到<code>Content-Length</code>对于 http 传输过程起到了十分关键的作用，如果设置不当可以直接导致传输失败。</p> <h3 id="不定长包体"><a href="#不定长包体" class="header-anchor">#</a> 不定长包体</h3> <p>上述是针对于<code>定长包体</code>，那么对于<code>不定长包体</code>而言是如何传输的呢？</p> <p>这里就必须介绍另外一个 http 头部字段了:</p> <div class="language-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token target symbol">Transfer-Encoding</span><span class="token punctuation">:</span> chunked
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>表示分块传输数据，设置这个字段后会自动产生两个效果:</p> <ul><li>Content-Length 字段会被忽略</li> <li>基于长连接持续推送动态内容</li></ul> <p>我们依然以一个实际的例子来模拟分块传输，nodejs 程序如下:</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;request&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>req<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Content-Type&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;text/html; charset=utf8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Content-Length&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">&quot;Transfer-Encoding&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;chunked&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;&lt;p&gt;来啦&lt;/p&gt;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;第一次传输&lt;br/&gt;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;第二次传输&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8009</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;成功启动&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
复制代码<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>访问效果入下:</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd728ba3840d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <p>用 telnet 抓到的响应如下:</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd78332368a0~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <p>注意，<code>Connection: keep-alive</code>及之前的为响应行和响应头，后面的内容为响应体，这两部分用换行符隔开。</p> <p>响应体的结构比较有意思，如下所示:</p> <div class="language-scss line-numbers-mode"><pre class="language-scss"><code>chunk长度<span class="token punctuation">(</span>16进制的数<span class="token punctuation">)</span>
第一个chunk的内容
chunk长度<span class="token punctuation">(</span>16进制的数<span class="token punctuation">)</span>
第二个chunk的内容
......
0

复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>最后是留有有一个<code>空行</code>的，这一点请大家注意。</p> <p>以上便是 http 对于<strong>定长数据</strong>和<strong>不定长数据</strong>的传输方式。</p> <h2 id="_008-http-如何处理大文件的传输"><a href="#_008-http-如何处理大文件的传输" class="header-anchor">#</a> 008: HTTP 如何处理大文件的传输？</h2> <p>对于几百 M 甚至上 G 的大文件来说，如果要一口气全部传输过来显然是不现实的，会有大量的等待时间，严重影响用户体验。因此，HTTP 针对这一场景，采取了<code>范围请求</code>的解决方案，允许客户端仅仅请求一个资源的一部分。</p> <h3 id="如何支持"><a href="#如何支持" class="header-anchor">#</a> 如何支持</h3> <p>当然，前提是服务器要支持<strong>范围请求</strong>，要支持这个功能，就必须加上这样一个响应头:</p> <div class="language-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token target symbol">Accept-Ranges</span><span class="token punctuation">:</span> none
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>用来告知客户端这边是支持范围请求的。</p> <h3 id="range-字段拆解"><a href="#range-字段拆解" class="header-anchor">#</a> Range 字段拆解</h3> <p>而对于客户端而言，它需要指定请求哪一部分，通过<code>Range</code>这个请求头字段确定，格式为<code>bytes=x-y</code>。接下来就来讨论一下这个 Range 的书写格式:</p> <ul><li><strong>0-499</strong>表示从开始到第 499 个字节。</li> <li><strong>500</strong>- 表示从第 500 字节到文件终点。</li> <li><strong>-100</strong>表示文件的最后 100 个字节。</li></ul> <p>服务器收到请求之后，首先验证范围<strong>是否合法</strong>，如果越界了那么返回<code>416</code>错误码，否则读取相应片段，返回<code>206</code>状态码。</p> <p>同时，服务器需要添加<code>Content-Range</code>字段，这个字段的格式根据请求头中<code>Range</code>字段的不同而有所差异。</p> <p>具体来说，请求<code>单段数据</code>和请求<code>多段数据</code>，响应头是不一样的。</p> <p>举个例子:</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code>// 单段数据
<span class="token key attr-name">Range: bytes</span><span class="token punctuation">=</span><span class="token value attr-value">0-9</span>
// 多段数据
<span class="token key attr-name">Range: bytes</span><span class="token punctuation">=</span><span class="token value attr-value">0-9, 30-39</span>

复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>接下来我们就分别来讨论着两种情况。</p> <h3 id="单段数据"><a href="#单段数据" class="header-anchor">#</a> 单段数据</h3> <p>对于<code>单段数据</code>的请求，返回的响应如下:</p> <div class="language-makefile line-numbers-mode"><pre class="language-makefile"><code>HTTP/1.1 206 Partial Content
<span class="token target symbol">Content-Length</span><span class="token punctuation">:</span> 10
<span class="token target symbol">Accept-Ranges</span><span class="token punctuation">:</span> bytes
<span class="token target symbol">Content-Range</span><span class="token punctuation">:</span> bytes 0-9/100

i am xxxxx
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>值得注意的是<code>Content-Range</code>字段，<code>0-9</code>表示请求的返回，<code>100</code>表示资源的总大小，很好理解。</p> <h3 id="多段数据"><a href="#多段数据" class="header-anchor">#</a> 多段数据</h3> <p>接下来我们看看多段请求的情况。得到的响应会是下面这个形式:</p> <div class="language-makefile line-numbers-mode"><pre class="language-makefile"><code>HTTP/1.1 206 Partial Content
<span class="token target symbol">Content-Type</span><span class="token punctuation">:</span> multipart/byteranges<span class="token punctuation">;</span> boundary<span class="token operator">=</span>00000010101
<span class="token target symbol">Content-Length</span><span class="token punctuation">:</span> 189
<span class="token target symbol">Connection</span><span class="token punctuation">:</span> keep-alive
<span class="token target symbol">Accept-Ranges</span><span class="token punctuation">:</span> bytes


--00000010101
<span class="token target symbol">Content-Type</span><span class="token punctuation">:</span> text/plain
<span class="token target symbol">Content-Range</span><span class="token punctuation">:</span> bytes 0-9/96

i am xxxxx
--00000010101
<span class="token target symbol">Content-Type</span><span class="token punctuation">:</span> text/plain
<span class="token target symbol">Content-Range</span><span class="token punctuation">:</span> bytes 20-29/96

eex jspy e
--00000010101--
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>这个时候出现了一个非常关键的字段<code>Content-Type: multipart/byteranges;boundary=00000010101</code>，它代表了信息量是这样的:</p> <ul><li>请求一定是多段数据请求</li> <li>响应体中的分隔符是 00000010101</li></ul> <p>因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上<code>--</code>表示结束。</p> <p>以上就是 http 针对大文件传输所采用的手段。</p> <h2 id="_009-http-中如何处理表单数据的提交"><a href="#_009-http-中如何处理表单数据的提交" class="header-anchor">#</a> 009: HTTP 中如何处理表单数据的提交？</h2> <p>在 http 中，有两种主要的表单提交的方式，体现在两种不同的<code>Content-Type</code>取值:</p> <ul><li>application/x-www-form-urlencoded</li> <li>multipart/form-data</li></ul> <p>由于表单提交一般是<code>POST</code>请求，很少考虑<code>GET</code>，因此这里我们将默认提交的数据放在请求体中。</p> <h3 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="header-anchor">#</a> application/x-www-form-urlencoded</h3> <p>对于<code>application/x-www-form-urlencoded</code>格式的表单内容，有以下特点:</p> <ul><li>其中的数据会被编码成以<code>&amp;</code>分隔的键值对</li> <li>字符以<strong>URL 编码方式</strong>编码。</li></ul> <p>如：</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token selector">// 转换过程:</span> <span class="token punctuation">{</span><span class="token property">a</span><span class="token punctuation">:</span> 1<span class="token punctuation">,</span> <span class="token property">b</span><span class="token punctuation">:</span> 2<span class="token punctuation">}</span> -&gt; a=1&amp;b=2 -&gt; 如下<span class="token punctuation">(</span>最终形式<span class="token punctuation">)</span>
<span class="token string">&quot;a%3D1%26b%3D2&quot;</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="multipart-form-data"><a href="#multipart-form-data" class="header-anchor">#</a> multipart/form-data</h3> <p>对于<code>multipart/form-data</code>而言:</p> <ul><li>请求头中的<code>Content-Type</code>字段会包含<code>boundary</code>，且<code>boundary</code>的值有浏览器默认指定。例: <code>Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe</code>。</li> <li>数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如<code>Content-Type</code>，在最后的分隔符会加上<code>--</code>表示结束。</li></ul> <p>相应的<code>请求体</code>是下面这样:</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code><span class="token property">Content-Disposition</span><span class="token punctuation">:</span> form-data<span class="token punctuation">;</span>name=<span class="token string">&quot;data1&quot;</span><span class="token punctuation">;</span>
<span class="token property">Content-Type</span><span class="token punctuation">:</span> text/plain
data1
----WebkitFormBoundaryRRJKeWfHPGrS4LKe
<span class="token property">Content-Disposition</span><span class="token punctuation">:</span> form-data<span class="token punctuation">;</span>name=<span class="token string">&quot;data2&quot;</span><span class="token punctuation">;</span>
<span class="token property">Content-Type</span><span class="token punctuation">:</span> text/plain
data2
----WebkitFormBoundaryRRJKeWfHPGrS4LKe--
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h3> <p>值得一提的是，<code>multipart/form-data</code> 格式最大的特点在于:<strong>每一个表单元素都是独立的资源表述</strong>。另外，你可能在写业务的过程中，并没有注意到其中还有<code>boundary</code>的存在，如果你打开抓包工具，确实可以看到不同的表单元素被拆分开了，之所以在平时感觉不到，是以为浏览器和 HTTP 给你封装了这一系列操作。</p> <p>而且，在实际的场景中，对于图片等文件的上传，基本采用<code>multipart/form-data</code>而不用<code>application/x-www-form-urlencoded</code>，因为没有必要做 URL 编码，带来巨大耗时的同时也占用了更多的空间。</p> <h2 id="_010-http1-1-如何解决-http-的队头阻塞问题"><a href="#_010-http1-1-如何解决-http-的队头阻塞问题" class="header-anchor">#</a> 010: HTTP1.1 如何解决 HTTP 的队头阻塞问题？</h2> <h3 id="什么是-http-队头阻塞"><a href="#什么是-http-队头阻塞" class="header-anchor">#</a> 什么是 HTTP 队头阻塞？</h3> <p>从前面的小节可以知道，HTTP 传输是基于<code>请求-应答</code>的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的<code>HTTP队头阻塞</code>问题。</p> <h3 id="并发连接"><a href="#并发连接" class="header-anchor">#</a> 并发连接</h3> <p>对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在 RFC2616 规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。</p> <p>但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。</p> <h3 id="域名分片"><a href="#域名分片" class="header-anchor">#</a> 域名分片</h3> <p>一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。</p> <p>比如 content1.sanyuan.com 、content2.sanyuan.com。</p> <p>这样一个<code>sanyuan.com</code>域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p> <h2 id="_011-对-cookie-了解多少"><a href="#_011-对-cookie-了解多少" class="header-anchor">#</a> 011: 对 Cookie 了解多少？</h2> <h3 id="cookie-简介"><a href="#cookie-简介" class="header-anchor">#</a> Cookie 简介</h3> <p>前面说到了 HTTP 是一个无状态的协议，每次 http 请求都是独立、无关的，默认不需要保留状态信息。但有时候需要保存一些状态，怎么办呢？</p> <p>HTTP 为此引入了 Cookie。Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储(在 chrome 开发者面板的 Application 这一栏可以看到)。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。而服务端可以通过响应头中的<code>Set-Cookie</code>字段来对客户端写入<code>Cookie</code>。举例如下:</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code>// 请求头
<span class="token key attr-name">Cookie: a</span><span class="token punctuation">=</span><span class="token value attr-value">xxx;b=xxx</span>
// 响应头
<span class="token key attr-name">Set-Cookie: a</span><span class="token punctuation">=</span><span class="token value attr-value">xxx</span>
<span class="token key attr-name">set-Cookie: b</span><span class="token punctuation">=</span><span class="token value attr-value">xxx</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="cookie-属性"><a href="#cookie-属性" class="header-anchor">#</a> Cookie 属性</h3> <h4 id="生存周期"><a href="#生存周期" class="header-anchor">#</a> 生存周期</h4> <p>Cookie 的有效期可以通过<strong>Expires</strong>和<strong>Max-Age</strong>两个属性来设置。</p> <ul><li><strong>Expires</strong>即<code>过期时间</code></li> <li><strong>Max-Age</strong>用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。</li></ul> <p>若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。</p> <h4 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h4> <p>关于作用域也有两个属性: <strong>Domain</strong>和<strong>path</strong>, 给 <strong>Cookie</strong> 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。值得注意的是，对于路径来说，<code>/</code>表示域名下的任意路径都允许使用 Cookie。</p> <h4 id="安全相关"><a href="#安全相关" class="header-anchor">#</a> 安全相关</h4> <p>如果带上<code>Secure</code>，说明只能通过 HTTPS 传输 cookie。</p> <p>如果 cookie 字段带上<code>HttpOnly</code>，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。</p> <p>相应的，对于 CSRF 攻击的预防，也有<code>SameSite</code>属性。</p> <p><code>SameSite</code>可以设置为三个值，<code>Strict</code>、<code>Lax</code>和<code>None</code>。</p> <p><strong>a.</strong> 在<code>Strict</code>模式下，浏览器完全禁止第三方请求携带 Cookie。比如请求<code>sanyuan.com</code>网站只能在<code>sanyuan.com</code>域名当中请求才能携带 Cookie，在其他网站请求都不能。</p> <p><strong>b.</strong> 在<code>Lax</code>模式，就宽松一点了，但是只能在 <code>get 方法提交表单</code>况或者<code>a 标签发送 get 请求</code>的情况下可以携带 Cookie，其他情况均不能。</p> <p><strong>c.</strong> 在<code>None</code>模式下，也就是默认模式，请求会自动携带上 Cookie。</p> <h3 id="cookie-的缺点"><a href="#cookie-的缺点" class="header-anchor">#</a> Cookie 的缺点</h3> <ol><li>容量缺陷。Cookie 的体积上限只有<code>4KB</code>，只能用来存储少量的信息。</li> <li>性能缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过<code>Domain</code>和<code>Path</code>指定<strong>作用域</strong>来解决。</li> <li>安全缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在<code>HttpOnly</code>为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。</li></ol> <h2 id="_012-如何理解-http-代理"><a href="#_012-如何理解-http-代理" class="header-anchor">#</a> 012: 如何理解 HTTP 代理？</h2> <p>我们知道在 HTTP 是基于<code>请求-响应</code>模型的协议，一般由客户端发请求，服务器来进行响应。</p> <p>当然，也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有<strong>双重身份</strong>。</p> <p>那代理服务器到底是用来做什么的呢？</p> <h3 id="功能"><a href="#功能" class="header-anchor">#</a> 功能</h3> <ol><li><strong>负载均衡</strong>。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括<strong>随机算法</strong>、<strong>轮询</strong>、<strong>一致性 hash</strong>、<strong>LRU</strong><code>(最近最少使用)</code>等等，不过这些算法并不是本文的重点，大家有兴趣自己可以研究一下。</li> <li><strong>保障安全</strong>。利用<strong>心跳</strong>机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。</li> <li><strong>缓存代理</strong>。将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。下一节详细拆解。</li></ol> <h3 id="相关头部字段"><a href="#相关头部字段" class="header-anchor">#</a> 相关头部字段</h3> <h4 id="via"><a href="#via" class="header-anchor">#</a> Via</h4> <p>代理服务器需要标明自己的身份，在 HTTP 传输中留下自己的痕迹，怎么办呢？</p> <p>通过<code>Via</code>字段来记录。举个例子，现在中间有两台代理服务器，在客户端发送请求后会经历这样一个过程:</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code>客户端 <span class="token punctuation">-&gt;</span> 代理<span class="token number">1</span> <span class="token punctuation">-&gt;</span> 代理<span class="token number">2</span> <span class="token punctuation">-&gt;</span> 源服务器
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在源服务器收到请求后，会在<code>请求头</code>拿到这个字段:</p> <div class="language-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token target symbol">Via</span><span class="token punctuation">:</span> proxy_server1, proxy_server2
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>而源服务器响应时，最终在客户端会拿到这样的<code>响应头</code>:</p> <div class="language-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token target symbol">Via</span><span class="token punctuation">:</span> proxy_server2, proxy_server1
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>可以看到，<code>Via</code>中代理的顺序即为在 HTTP 传输中报文传达的顺序。</p> <h4 id="x-forwarded-for"><a href="#x-forwarded-for" class="header-anchor">#</a> X-Forwarded-For</h4> <p>字面意思就是<code>为谁转发</code>, 它记录的是<strong>请求方</strong>的<code>IP</code>地址(注意，和<code>Via</code>区分开，<code>X-Forwarded-For</code>记录的是请求方这一个 IP)。</p> <h4 id="x-real-ip"><a href="#x-real-ip" class="header-anchor">#</a> X-Real-IP</h4> <p>是一种获取用户真实 IP 的字段，不管中间经过多少代理，这个字段始终记录最初的客户端的 IP。</p> <p>相应的，还有<code>X-Forwarded-Host</code>和<code>X-Forwarded-Proto</code>，分别记录<strong>客户端</strong>(注意哦，不包括代理)的<code>域名</code>和<code>协议名</code>。</p> <h3 id="x-forwarded-for-产生的问题"><a href="#x-forwarded-for-产生的问题" class="header-anchor">#</a> X-Forwarded-For 产生的问题</h3> <p>前面可以看到，<code>X-Forwarded-For</code>这个字段记录的是请求方的 IP，这意味着每经过一个不同的代理，这个字段的名字都要变，从<code>客户端</code>到<code>代理1</code>，这个字段是客户端的 IP，从<code>代理1</code>到<code>代理2</code>，这个字段就变为了代理 1 的 IP。</p> <p>但是这会产生两个问题:</p> <ol><li>意味着代理必须解析 HTTP 请求头，然后修改，比直接转发数据性能下降。</li> <li>在 HTTPS 通信加密的过程中，原始报文是不允许修改的。</li></ol> <p>由此产生了<code>代理协议</code>，一般使用明文版本，只需要在 HTTP 请求行上面加上这样格式的文本即可:</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code>// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口
PROXY TCP4 0.0.0.1 0.0.0.2 1111 2222
GET / HTTP/1.1
<span class="token punctuation">---</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这样就可以解决<code>X-Forwarded-For</code>带来的问题了。</p> <h2 id="_013-如何理解-http-缓存及缓存代理"><a href="#_013-如何理解-http-缓存及缓存代理" class="header-anchor">#</a> 013: 如何理解 HTTP 缓存及缓存代理？</h2> <p>首先通过 <code>Cache-Control</code> 验证强缓存是否可用</p> <ul><li><p>如果强缓存可用，直接使用</p></li> <li><p>否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>If-Modified-Since
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>或者</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>If-None-Match
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>这些</p> <p>条件请求</p> <p>字段检查资源是否更新</p> <ul><li>若资源更新，返回资源和 200 状态码</li> <li>否则，返回 304，告诉浏览器直接从缓存获取资源</li></ul></li></ul> <p>这一节我们主要来说说另外一种缓存方式: <strong>代理缓存</strong>。</p> <h3 id="为什么产生代理缓存"><a href="#为什么产生代理缓存" class="header-anchor">#</a> 为什么产生代理缓存？</h3> <p>对于源服务器来说，它也是有缓存的，比如<strong>Redis, Memcache</strong>，但对于 HTTP 缓存来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的。</p> <p>由此引入了<strong>缓存代理</strong>的机制。让<code>代理服务器</code>接管一部分的服务端 HTTP 缓存，客户端缓存过期后<strong>就近</strong>到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候能明显降低源服务器的压力。</p> <p>那缓存代理究竟是如何做到的呢？</p> <p>总的来说，缓存代理的控制分为两部分，一部分是<strong>源服务器</strong>端的控制，一部分是<strong>客户端</strong>的控制。</p> <h3 id="源服务器的缓存控制"><a href="#源服务器的缓存控制" class="header-anchor">#</a> 源服务器的缓存控制</h3> <h4 id="private-和-public"><a href="#private-和-public" class="header-anchor">#</a> private 和 public</h4> <p>在源服务器的响应头中，会加上<code>Cache-Control</code>这个字段进行缓存控制字段，那么它的值当中可以加入<code>private</code>或者<code>public</code>表示是否允许代理服务器缓存，前者禁止，后者为允许。</p> <p>比如对于一些非常私密的数据，如果缓存到代理服务器，别人直接访问代理就可以拿到这些数据，是非常危险的，因此对于这些数据一般是不会允许代理服务器进行缓存的，将响应头部的<code>Cache-Control</code>设为<code>private</code>，而不是<code>public</code>。</p> <h4 id="proxy-revalidate"><a href="#proxy-revalidate" class="header-anchor">#</a> proxy-revalidate</h4> <p><code>must-revalidate</code>的意思是<strong>客户端</strong>缓存过期就去源服务器获取，而<code>proxy-revalidate</code>则表示<strong>代理服务器</strong>的缓存过期后到源服务器获取。</p> <h4 id="s-maxage"><a href="#s-maxage" class="header-anchor">#</a> s-maxage</h4> <p><code>s</code>是<code>share</code>的意思，限定了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的<code>max-age</code>并不冲突。</p> <p>讲了这几个字段，我们不妨来举个小例子，源服务器在响应头中加入这样一个字段:</p> <div class="language-arduino line-numbers-mode"><pre class="language-arduino"><code>Cache<span class="token operator">-</span>Control<span class="token operator">:</span> public<span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token operator">-</span>age<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">,</span> s<span class="token operator">-</span>maxage<span class="token operator">=</span><span class="token number">2000</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>相当于源服务器说: 我这个响应是允许代理服务器缓存的，客户端缓存过期了到代理中拿，并且在客户端的缓存时间为 1000 秒，在代理服务器中的缓存时间为 2000 s。</p> <h3 id="客户端的缓存控制"><a href="#客户端的缓存控制" class="header-anchor">#</a> 客户端的缓存控制</h3> <h4 id="max-stale-和-min-fresh"><a href="#max-stale-和-min-fresh" class="header-anchor">#</a> max-stale 和 min-fresh</h4> <p>在客户端的请求头中，可以加入这两个字段，来对代理服务器上的缓存进行<strong>宽容</strong>和<strong>限制</strong>操作。比如：</p> <div class="language-arduino line-numbers-mode"><pre class="language-arduino"><code><span class="token builtin">max</span><span class="token operator">-</span>stale<span class="token operator">:</span> <span class="token number">5</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>表示客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也不要紧，只要过期时间在<strong>5 秒之内</strong>，还是可以从代理中获取的。</p> <p>又比如:</p> <div class="language-arduino line-numbers-mode"><pre class="language-arduino"><code><span class="token builtin">min</span><span class="token operator">-</span>fresh<span class="token operator">:</span> <span class="token number">5</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，一定要在<strong>到期前 5 秒</strong>之前的时间拿，否则拿不到。</p> <h4 id="only-if-cached"><a href="#only-if-cached" class="header-anchor">#</a> only-if-cached</h4> <p>这个字段加上后表示客户端只会接受代理缓存，而不会接受源服务器的响应。如果代理缓存无效，则直接返回<code>504（Gateway Timeout）</code>。</p> <p>以上便是缓存代理的内容，涉及的字段比较多，希望能好好回顾一下，加深理解。</p> <h2 id="_014-什么是跨域-浏览器如何拦截响应-如何解决"><a href="#_014-什么是跨域-浏览器如何拦截响应-如何解决" class="header-anchor">#</a> 014: 什么是跨域？浏览器如何拦截响应？如何解决？</h2> <p>在前后端分离的开发模式中，经常会遇到跨域问题，即 Ajax 请求发出去了，服务器也成功响应了，前端就是拿不到这个响应。接下来我们就来好好讨论一下这个问题。</p> <h3 id="什么是跨域"><a href="#什么是跨域" class="header-anchor">#</a> 什么是跨域</h3> <p>回顾一下 URI 的组成:</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd7ac23846fe~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <p>浏览器遵循<strong>同源政策</strong>(<code>scheme(协议)</code>、<code>host(主机)</code>和<code>port(端口)</code>都相同则为<code>同源</code>)。非同源站点有这样一些限制:</p> <ul><li>不能读取和修改对方的 DOM</li> <li>不读访问对方的 Cookie、IndexDB 和 LocalStorage</li> <li>限制 XMLHttpRequest 请求。(后面的话题着重围绕这个)</li></ul> <p>当浏览器向目标 URI 发 Ajax 请求时，只要当前 URL 和目标 URL 不同源，则产生跨域，被称为<code>跨域请求</code>。</p> <p>跨域请求的响应一般会被浏览器所拦截，注意，是被浏览器拦截，响应其实是成功到达客户端了。那这个拦截是如何发生呢？</p> <p>首先要知道的是，浏览器是多进程的，以 Chrome 为例，进程组成如下：</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd8131a4628f~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd83a20647db~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <p><strong>WebKit 渲染引擎</strong>和<strong>V8 引擎</strong>都在渲染进程当中。</p> <p>当<code>xhr.send</code>被调用，即 Ajax 请求准备发送的时候，其实还只是在渲染进程的处理。为了防止黑客通过脚本触碰到系统资源，浏览器将每一个渲染进程装进了沙箱，并且为了防止 CPU 芯片一直存在的<strong>Spectre</strong> 和 <strong>Meltdown</strong>漏洞，采取了<code>站点隔离</code>的手段，给每一个不同的站点(一级域名不同)分配了沙箱，互不干扰。具体见<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DdBuykrdhK-A%26feature%3Demb_logo" target="_blank" rel="noopener noreferrer">YouTube 上 Chromium 安全团队的演讲视频<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>在沙箱当中的渲染进程是没有办法发送网络请求的，那怎么办？只能通过网络进程来发送。那这样就涉及到进程间通信(IPC，Inter Process Communication)了。接下来我们看看 chromium 当中进程间通信是如何完成的，在 chromium 源码中调用顺序如下:</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd924eaecb41~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <p>可能看了你会比较懵，如果想深入了解可以去看看 chromium 最新的源代码，<a href="https://link.juejin.cn?target=https%3A%2F%2Fchromium.googlesource.com%2Fchromium%2Fsrc%2F%2B%2Frefs%2Fheads%2Fmaster%2Fipc%2F" target="_blank" rel="noopener noreferrer">IPC 源码地址<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>及<a href="https://link.juejin.cn?target=https%3A%2F%2Fblog.csdn.net%2FLuoshengyang%2Farticle%2Fdetails%2F47822689" target="_blank" rel="noopener noreferrer">Chromium IPC 源码解析文章<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>总的来说就是利用<code>Unix Domain Socket</code>套接字，配合事件驱动的高性能网络并发库<code>libevent</code>完成进程的 IPC 过程。</p> <p>好，现在数据传递给了浏览器主进程，主进程接收到后，才真正地发出相应的网络请求。</p> <p>在服务端处理完数据后，将响应返回，主进程检查到跨域，且没有 cors(后面会详细说)响应头，将响应体全部丢掉，并不会发送给渲染进程。这就达到了拦截数据的目的。</p> <p>接下来我们来说一说解决跨域问题的几种方案。</p> <h3 id="cors"><a href="#cors" class="header-anchor">#</a> CORS</h3> <p>CORS 其实是 W3C 的一个标准，全称是<code>跨域资源共享</code>。它需要浏览器和服务器的共同支持，具体来说，非 IE 和 IE10 以上支持 CORS，服务器需要附加特定的响应头，后面具体拆解。不过在弄清楚 CORS 的原理之前，我们需要清楚两个概念: <strong>简单请求</strong>和<strong>非简单请求</strong>。</p> <p>浏览器根据请求方法和请求头的特定字段，将请求做了一下分类，具体来说规则是这样，凡是满足下面条件的属于<strong>简单请求</strong>:</p> <ul><li>请求方法为 GET、POST 或者 HEAD</li> <li>请求头的取值范围: Accept、Accept-Language、Content-Language、Content-Type(只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>)</li></ul> <p>浏览器画了这样一个圈，在这个圈里面的就是<strong>简单请求</strong>, 圈外面的就是<strong>非简单请求</strong>，然后针对这两种不同的请求进行不同的处理。</p> <h4 id="简单请求"><a href="#简单请求" class="header-anchor">#</a> 简单请求</h4> <p>请求发出去之前，浏览器做了什么？</p> <p>它会自动在请求头当中，添加一个<code>Origin</code>字段，用来说明请求来自哪个<code>源</code>。服务器拿到请求之后，在回应时对应地添加<code>Access-Control-Allow-Origin</code>字段，如果<code>Origin</code>不在这个字段的范围中，那么浏览器就会将响应拦截。</p> <p>因此，<code>Access-Control-Allow-Origin</code>字段是服务器用来决定浏览器是否拦截这个响应，这是必需的字段。与此同时，其它一些可选的功能性的字段，用来描述如果不会拦截，这些字段将会发挥各自的作用。</p> <p><strong>Access-Control-Allow-Credentials</strong>。这个字段是一个布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器对这个字段默认值设为 false，而如果需要拿到浏览器的 Cookie，需要添加这个响应头并设为<code>true</code>, 并且在前端也需要设置<code>withCredentials</code>属性:</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code><span class="token key attr-name">let xhr</span> <span class="token punctuation">=</span> <span class="token value attr-value">new XMLHttpRequest();</span>
<span class="token key attr-name">xhr.withCredentials</span> <span class="token punctuation">=</span> <span class="token value attr-value">true;</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>Access-Control-Expose-Headers</strong>。这个字段是给 XMLHttpRequest 对象赋能，让它不仅可以拿到基本的 6 个响应头字段（包括<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>和<code>Pragma</code>）, 还能拿到这个字段声明的<strong>响应头字段</strong>。比如这样设置:</p> <div class="language-makefile line-numbers-mode"><pre class="language-makefile"><code><span class="token target symbol">Access-Control-Expose-Headers</span><span class="token punctuation">:</span> aaa
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>那么在前端可以通过 <code>XMLHttpRequest.getResponseHeader('aaa')</code> 拿到 <code>aaa</code> 这个字段的值。</p> <h4 id="非简单请求"><a href="#非简单请求" class="header-anchor">#</a> 非简单请求</h4> <p>非简单请求相对而言会有些不同，体现在两个方面: <strong>预检请求</strong>和<strong>响应字段</strong>。</p> <p>我们以 PUT 方法为例。</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code><span class="token key attr-name">var url</span> <span class="token punctuation">=</span> <span class="token value attr-value">'http://xxx.com';</span>
<span class="token key attr-name">var xhr</span> <span class="token punctuation">=</span> <span class="token value attr-value">new XMLHttpRequest();</span>
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'xxx');
xhr.send();
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>当这段代码执行后，首先会发送<strong>预检请求</strong>。这个预检请求的请求行和请求体是下面这个格式:</p> <div class="language-makefile line-numbers-mode"><pre class="language-makefile"><code>OPTIONS / HTTP/1.1
<span class="token target symbol">Origin</span><span class="token punctuation">:</span> 当前地址
<span class="token target symbol">Host</span><span class="token punctuation">:</span> xxx.com
<span class="token target symbol">Access-Control-Request-Method</span><span class="token punctuation">:</span> PUT
<span class="token target symbol">Access-Control-Request-Headers</span><span class="token punctuation">:</span> X-Custom-Header
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>预检请求的方法是<code>OPTIONS</code>，同时会加上<code>Origin</code>源地址和<code>Host</code>目标地址，这很简单。同时也会加上两个关键的字段:</p> <ul><li>Access-Control-Request-Method, 列出 CORS 请求用到哪个 HTTP 方法</li> <li>Access-Control-Request-Headers，指定 CORS 请求将要加上什么请求头</li></ul> <p>这是<code>预检请求</code>。接下来是<strong>响应字段</strong>，响应字段也分为两部分，一部分是对于<strong>预检请求</strong>的响应，一部分是对于 <strong>CORS 请求</strong>的响应。</p> <p><strong>预检请求的响应</strong>。如下面的格式:</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code>HTTP/1.1 200 OK
<span class="token key atrule">Access-Control-Allow-Origin</span><span class="token punctuation">:</span> *
<span class="token key atrule">Access-Control-Allow-Methods</span><span class="token punctuation">:</span> GET<span class="token punctuation">,</span> POST<span class="token punctuation">,</span> PUT
<span class="token key atrule">Access-Control-Allow-Headers</span><span class="token punctuation">:</span> X<span class="token punctuation">-</span>Custom<span class="token punctuation">-</span>Header
<span class="token key atrule">Access-Control-Allow-Credentials</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">Access-Control-Max-Age</span><span class="token punctuation">:</span> <span class="token number">1728000</span>
<span class="token key atrule">Content-Type</span><span class="token punctuation">:</span> text/html; charset=utf<span class="token punctuation">-</span><span class="token number">8</span>
<span class="token key atrule">Content-Encoding</span><span class="token punctuation">:</span> gzip
<span class="token key atrule">Content-Length</span><span class="token punctuation">:</span> <span class="token number">0</span>
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>其中有这样几个关键的<strong>响应头字段</strong>:</p> <ul><li>Access-Control-Allow-Origin: 表示可以允许请求的源，可以填具体的源名，也可以填<code>*</code>表示允许任意源请求。</li> <li>Access-Control-Allow-Methods: 表示允许的请求方法列表。</li> <li>Access-Control-Allow-Credentials: 简单请求中已经介绍。</li> <li>Access-Control-Allow-Headers: 表示允许发送的请求头字段</li> <li>Access-Control-Max-Age: 预检请求的有效期，在此期间，不用发出另外一条预检请求。</li></ul> <p>在预检请求的响应返回后，如果请求不满足响应头的条件，则触发<code>XMLHttpRequest</code>的<code>onerror</code>方法，当然后面真正的<strong>CORS 请求</strong>也不会发出去了。</p> <p><strong>CORS 请求的响应</strong>。绕了这么一大转，到了真正的 CORS 请求就容易多了，现在它和<strong>简单请求</strong>的情况是一样的。浏览器自动加上<code>Origin</code>字段，服务端响应头返回<strong>Access-Control-Allow-Origin</strong>。可以参考以上简单请求部分的内容。</p> <h3 id="jsonp"><a href="#jsonp" class="header-anchor">#</a> JSONP</h3> <p>虽然<code>XMLHttpRequest</code>对象遵循同源政策，但是<code>script</code>标签不一样，它可以通过 src 填上目标地址从而发出 GET 请求，实现跨域请求并拿到响应。这也就是 JSONP 的原理，接下来我们就来封装一个 JSONP:</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">jsonp</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> callbackName <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">generateURL</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> dataStr <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      dataStr <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>params<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">&amp;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    dataStr <span class="token operator">+=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">callback=</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callbackName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>url<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">?</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dataStr<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 初始化回调函数名称</span>
    callbackName <span class="token operator">=</span> callbackName <span class="token operator">||</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建 script 元素并加入到当前文档中</span>
    <span class="token keyword">let</span> scriptEle <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&quot;script&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    scriptEle<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token function">generateURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>scriptEle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 绑定到 window 上，为了后面调用</span>
    window<span class="token punctuation">[</span>callbackName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// script 执行完了，成为无用元素，需要清除</span>
      document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>scriptEle<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
复制代码<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>当然在服务端也会有响应的操作, 以 express 为例:</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;express&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> callback <span class="token punctuation">}</span> <span class="token operator">=</span> req<span class="token punctuation">.</span>query<span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
  <span class="token comment">// 注意哦，返回给script标签，浏览器直接把这部分字符串执行</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>callback<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">('数据包')</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
复制代码<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>前端这样简单地调用一下就好了:</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">&quot;http://localhost:3000&quot;</span><span class="token punctuation">,</span>
  <span class="token literal-property property">params</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 拿到数据进行处理</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 数据包</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
复制代码<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>和<code>CORS</code>相比，JSONP 最大的优势在于兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP，缺点也很明显，请求方法单一，只支持 GET 请求。</p> <h3 id="nginx"><a href="#nginx" class="header-anchor">#</a> Nginx</h3> <p>Nginx 是一种高性能的<code>反向代理</code>服务器，可以用来轻松解决跨域问题。</p> <p>what？反向代理？我给你看一张图你就懂了。</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffd97d0b1cf15~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <p>正向代理帮助客户端<strong>访问</strong>客户端自己访问不到的服务器，然后将结果返回给客户端。</p> <p>反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的<strong>负载均衡</strong>，换句话说，反向代理帮<strong>其它的服务器</strong>拿到请求，然后选择一个合适的服务器，将请求转交给它。</p> <p>因此，两者的区别就很明显了，正向代理服务器是帮<strong>客户端</strong>做事情，而反向代理服务器是帮其它的<strong>服务器</strong>做事情。</p> <p>好了，那 Nginx 是如何来解决跨域的呢？</p> <p>比如说现在客户端的域名为<strong>client.com</strong>，服务器的域名为<strong>server.com</strong>，客户端向服务器发送 Ajax 请求，当然会跨域了，那这个时候让 Nginx 登场了，通过下面这个配置:</p> <div class="language-ini line-numbers-mode"><pre class="language-ini"><code>server {
  listen  80;
  server_name  client.com;
  location /api {
    proxy_pass server.com;
  }
}
复制代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Nginx 相当于起了一个跳板机，这个跳板机的域名也是<code>client.com</code>，让客户端首先访问 <code>client.com/api</code>，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给<code>server.com</code>，当响应返回时又将响应给到客户端，这就完成整个跨域请求的过程。</p> <p>其实还有一些不太常用的方式，大家了解即可，比如<code>postMessage</code>，当然<code>WebSocket</code>也是一种方式，但是已经不属于 HTTP 的范畴，另外一些奇技淫巧就不建议大家去死记硬背了，一方面从来不用，名字都难得记住，另一方面临时背下来，面试官也不会对你印象加分，因为看得出来是背的。当然没有背并不代表减分，把跨域原理和前面三种主要的跨域方式理解清楚，经得起更深一步的推敲，反而会让别人觉得你是一个靠谱的人。</p> <h2 id="_015-http-2-有哪些改进"><a href="#_015-http-2-有哪些改进" class="header-anchor">#</a> 015: HTTP/2 有哪些改进？</h2> <p>由于 HTTPS 在安全方面已经做的非常好了，HTTP 改进的关注点放在了性能方面。对于 HTTP/2 而言，它对于性能的提升主要在于两点:</p> <ul><li>头部压缩</li> <li>多路复用</li></ul> <p>当然还有一些颠覆性的功能实现:</p> <ul><li>设置请求优先级</li> <li>服务器推送</li></ul> <p>这些重大的提升本质上也是为了解决 HTTP 本身的问题而产生的。接下来我们来看看 HTTP/2 解决了哪些问题，以及解决方式具体是如何的。</p> <h3 id="头部压缩"><a href="#头部压缩" class="header-anchor">#</a> 头部压缩</h3> <p>在 HTTP/1.1 及之前的时代，<strong>请求体</strong>一般会有响应的压缩编码过程，通过<code>Content-Encoding</code>头部字段来指定，但你有没有想过头部字段本身的压缩呢？当请求字段非常复杂的时候，尤其对于 GET 请求，请求报文几乎全是请求头，这个时候还是存在非常大的优化空间的。HTTP/2 针对头部字段，也采用了对应的压缩算法——HPACK，对请求头进行压缩。</p> <p>HPACK 算法是专门为 HTTP/2 服务的，它主要的亮点有两个：</p> <ul><li>首先是在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把<strong>索引</strong>(比如 0，1，2，...)传给对方即可，对方拿到索引查表就行了。这种<strong>传索引</strong>的方式，可以说让请求头字段得到极大程度的精简和复用。</li></ul> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffdaa6f41c004~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <blockquote><p>HTTP/2 当中废除了起始行的概念，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个&quot;:&quot;前缀，用来和其它请求头区分开。</p></blockquote> <ul><li>其次是对于整数和字符串进行<strong>哈夫曼编码</strong>，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的<strong>索引序列</strong>，可以达到非常高的压缩率。</li></ul> <h3 id="多路复用"><a href="#多路复用" class="header-anchor">#</a> 多路复用</h3> <h4 id="http-队头阻塞"><a href="#http-队头阻塞" class="header-anchor">#</a> HTTP 队头阻塞</h4> <p>我们之前讨论了 HTTP 队头阻塞的问题，其根本原因在于 HTTP 基于<code>请求-响应</code>的模型，在同一个 TCP 长连接中，前面的请求没有得到响应，后面的请求就会被阻塞。</p> <p>后面我们又讨论到用<strong>并发连接</strong>和<strong>域名分片</strong>的方式来解决这个问题，但这并没有真正从 HTTP 本身的层面解决问题，只是增加了 TCP 连接，分摊风险而已。而且这么做也有弊端，多条 TCP 连接会竞争<strong>有限的带宽</strong>，让真正优先级高的请求不能优先处理。</p> <p>而 HTTP/2 便从 HTTP 协议本身解决了<code>队头阻塞</code>问题。注意，这里并不是指的<code>TCP队头阻塞</code>，而是<code>HTTP队头阻塞</code>，两者并不是一回事。TCP 的队头阻塞是在<code>数据包</code>层面，单位是<code>数据包</code>，前一个报文没有收到便不会将后面收到的报文上传给 HTTP，而 HTTP 的队头阻塞是在 <code>HTTP 请求-响应</code>层面，前一个请求没处理完，后面的请求就要阻塞住。两者所在的层次不一样。</p> <p>那么 HTTP/2 如何来解决所谓的队头阻塞呢？</p> <h4 id="二进制分帧"><a href="#二进制分帧" class="header-anchor">#</a> 二进制分帧</h4> <p>首先，HTTP/2 认为明文传输对机器而言太麻烦了，不方便计算机的解析，因为对于文本而言会有多义性的字符，比如回车换行到底是内容还是分隔符，在内部需要用到状态机去识别，效率比较低。于是 HTTP/2 干脆把报文全部换成二进制格式，全部传输<code>01</code>串，方便了机器的解析。</p> <p>原来<code>Headers + Body</code>的报文格式如今被拆分成了一个个二进制的帧，用<strong>Headers 帧</strong>存放头部字段，<strong>Data 帧</strong>存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。</p> <p>通信双方都可以给对方发送二进制帧，这种二进制帧的<strong>双向传输的序列</strong>，也叫做<code>流</code>(Stream)。HTTP/2 用<code>流</code>来在一个 TCP 连接上来进行多个数据帧的通信，这就是<strong>多路复用</strong>的概念。</p> <p>可能你会有一个疑问，既然是乱序首发，那最后如何来处理这些乱序的数据帧呢？</p> <p>首先要声明的是，所谓的乱序，指的是不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按顺序传输的。二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的<strong>请求报文</strong>和<strong>响应报文</strong>。当然，在二进制帧当中还有其他的一些字段，实现了<strong>优先级</strong>和<strong>流量控制</strong>等功能，我们放到下一节再来介绍。</p> <h3 id="服务器推送"><a href="#服务器推送" class="header-anchor">#</a> 服务器推送</h3> <p>另外值得一说的是 HTTP/2 的服务器推送(Server Push)。在 HTTP/2 当中，服务器已经不再是完全被动地接收请求，响应请求，它也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>当然，HTTP/2 新增那么多的特性，是不是 HTTP 的语法要重新学呢？不需要，HTTP/2 完全兼容之前 HTTP 的语法和语义，如<strong>请求头、URI、状态码、头部字段</strong>都没有改变，完全不用担心。同时，在安全方面，HTTP 也支持 TLS，并且现在主流的浏览器都公开只支持加密的 HTTP/2, 因此你现在能看到的 HTTP/2 也基本上都是跑在 TLS 上面的了。最后放一张分层图给大家参考:</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffdc6783132a5~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <h2 id="_016-http-2-中的二进制帧是如何设计的"><a href="#_016-http-2-中的二进制帧是如何设计的" class="header-anchor">#</a> 016: HTTP/2 中的二进制帧是如何设计的？</h2> <h3 id="帧结构"><a href="#帧结构" class="header-anchor">#</a> 帧结构</h3> <p>HTTP/2 中传输的帧结构如下图所示:</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffdc9e9c25e93~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <p>每个帧分为<code>帧头</code>和<code>帧体</code>。先是三个字节的帧长度，这个长度表示的是<code>帧体</code>的长度。</p> <p>然后是帧类型，大概可以分为<strong>数据帧</strong>和<strong>控制帧</strong>两种。数据帧用来存放 HTTP 报文，控制帧用来管理<code>流</code>的传输。</p> <p>接下来的一个字节是<strong>帧标志</strong>，里面一共有 8 个标志位，常用的有 <strong>END_HEADERS</strong>表示头数据结束，<strong>END_STREAM</strong>表示单方向数据发送结束。</p> <p>后 4 个字节是<code>Stream ID</code>, 也就是<code>流标识符</code>，有了它，接收方就能从乱序的二进制帧中选择出 ID 相同的帧，按顺序组装成请求/响应报文。</p> <h3 id="流的状态变化"><a href="#流的状态变化" class="header-anchor">#</a> 流的状态变化</h3> <p>从前面可以知道，在 HTTP/2 中，所谓的<code>流</code>，其实就是二进制帧的<strong>双向传输的序列</strong>。那么在 HTTP/2 请求和响应的过程中，流的状态是如何变化的呢？</p> <p>HTTP/2 其实也是借鉴了 TCP 状态变化的思想，根据帧的标志位来实现具体的状态改变。这里我们以一个普通的<code>请求-响应</code>过程为例来说明：</p> <p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/22/170ffdcd0abdd1ba~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p> <p>最开始两者都是空闲状态，当客户端发送<code>Headers帧</code>后，开始分配<code>Stream ID</code>, 此时客户端的<code>流</code>打开, 服务端接收之后服务端的<code>流</code>也打开，两端的<code>流</code>都打开之后，就可以互相传递数据帧和控制帧了。</p> <p>当客户端要关闭时，向服务端发送<code>END_STREAM</code>帧，进入<code>半关闭状态</code>, 这个时候客户端只能接收数据，而不能发送数据。</p> <p>服务端收到这个<code>END_STREAM</code>帧后也进入<code>半关闭状态</code>，不过此时服务端的情况是只能发送数据，而不能接收数据。随后服务端也向客户端发送<code>END_STREAM</code>帧，表示数据发送完毕，双方进入<code>关闭状态</code>。</p> <p>如果下次要开启新的<code>流</code>，流 ID 需要自增，直到上限为止，到达上限后开一个新的 TCP 连接重头开始计数。由于流 ID 字段长度为 4 个字节，最高位又被保留，因此范围是 0 ~ 2 的 31 次方，大约 21 亿个。</p> <h3 id="流的特性"><a href="#流的特性" class="header-anchor">#</a> 流的特性</h3> <p>刚刚谈到了流的状态变化过程，这里顺便就来总结一下<code>流</code>传输的特性:</p> <ul><li>并发性。一个 HTTP/2 连接上可以同时发多个帧，这一点和 HTTP/1 不同。这也是实现<strong>多路</strong>复用的基础。</li> <li>自增性。流 ID 是不可重用的，而是会按顺序递增，达到上限之后又新开 TCP 连接从头开始。</li> <li>双向性。客户端和服务端都可以创建流，互不干扰，双方都可以作为<code>发送方</code>或者<code>接收方</code>。</li> <li>可设置优先级。可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</li></ul></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_001-http-报文结构是怎样的" class="sidebar-link reco-side-_001-http-报文结构是怎样的" data-v-70334359>001. HTTP 报文结构是怎样的？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#起始行" class="sidebar-link reco-side-起始行" data-v-70334359>起始行</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#头部" class="sidebar-link reco-side-头部" data-v-70334359>头部</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#空行" class="sidebar-link reco-side-空行" data-v-70334359>空行</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#实体" class="sidebar-link reco-side-实体" data-v-70334359>实体</a></li><li class="level-2" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_002-如何理解-http-的请求方法" class="sidebar-link reco-side-_002-如何理解-http-的请求方法" data-v-70334359>002. 如何理解 HTTP 的请求方法？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#有哪些请求方法" class="sidebar-link reco-side-有哪些请求方法" data-v-70334359>有哪些请求方法？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#get-和-post-有什么区别" class="sidebar-link reco-side-get-和-post-有什么区别" data-v-70334359>GET 和 POST 有什么区别？</a></li><li class="level-2" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_003-如何理解-uri" class="sidebar-link reco-side-_003-如何理解-uri" data-v-70334359>003: 如何理解 URI？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#uri-的结构" class="sidebar-link reco-side-uri-的结构" data-v-70334359>URI 的结构</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#uri-编码" class="sidebar-link reco-side-uri-编码" data-v-70334359>URI 编码</a></li><li class="level-2" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_004-如何理解-http-状态码" class="sidebar-link reco-side-_004-如何理解-http-状态码" data-v-70334359>004: 如何理解 HTTP 状态码？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_1xx" class="sidebar-link reco-side-_1xx" data-v-70334359>1xx</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_2xx" class="sidebar-link reco-side-_2xx" data-v-70334359>2xx</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_3xx" class="sidebar-link reco-side-_3xx" data-v-70334359>3xx</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_4xx" class="sidebar-link reco-side-_4xx" data-v-70334359>4xx</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_5xx" class="sidebar-link reco-side-_5xx" data-v-70334359>5xx</a></li><li class="level-2" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_005-简要概括一下-http-的特点-http-有哪些缺点" class="sidebar-link reco-side-_005-简要概括一下-http-的特点-http-有哪些缺点" data-v-70334359>005: 简要概括一下 HTTP 的特点？HTTP 有哪些缺点？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#http-特点" class="sidebar-link reco-side-http-特点" data-v-70334359>HTTP 特点</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#http-缺点" class="sidebar-link reco-side-http-缺点" data-v-70334359>HTTP 缺点</a></li><li class="level-2" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_006-对-accept-系列字段了解多少" class="sidebar-link reco-side-_006-对-accept-系列字段了解多少" data-v-70334359>006: 对 Accept 系列字段了解多少？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#数据格式" class="sidebar-link reco-side-数据格式" data-v-70334359>数据格式</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#压缩方式" class="sidebar-link reco-side-压缩方式" data-v-70334359>压缩方式</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#支持语言" class="sidebar-link reco-side-支持语言" data-v-70334359>支持语言</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#字符集" class="sidebar-link reco-side-字符集" data-v-70334359>字符集</a></li><li class="level-2" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_007-对于定长和不定长的数据-http-是怎么传输的" class="sidebar-link reco-side-_007-对于定长和不定长的数据-http-是怎么传输的" data-v-70334359>007: 对于定长和不定长的数据，HTTP 是怎么传输的？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#定长包体" class="sidebar-link reco-side-定长包体" data-v-70334359>定长包体</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#不定长包体" class="sidebar-link reco-side-不定长包体" data-v-70334359>不定长包体</a></li><li class="level-2" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_008-http-如何处理大文件的传输" class="sidebar-link reco-side-_008-http-如何处理大文件的传输" data-v-70334359>008: HTTP 如何处理大文件的传输？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#如何支持" class="sidebar-link reco-side-如何支持" data-v-70334359>如何支持</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#range-字段拆解" class="sidebar-link reco-side-range-字段拆解" data-v-70334359>Range 字段拆解</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#单段数据" class="sidebar-link reco-side-单段数据" data-v-70334359>单段数据</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#多段数据" class="sidebar-link reco-side-多段数据" data-v-70334359>多段数据</a></li><li class="level-2" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_009-http-中如何处理表单数据的提交" class="sidebar-link reco-side-_009-http-中如何处理表单数据的提交" data-v-70334359>009: HTTP 中如何处理表单数据的提交？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#application-x-www-form-urlencoded" class="sidebar-link reco-side-application-x-www-form-urlencoded" data-v-70334359>application/x-www-form-urlencoded</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#multipart-form-data" class="sidebar-link reco-side-multipart-form-data" data-v-70334359>multipart/form-data</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#小结" class="sidebar-link reco-side-小结" data-v-70334359>小结</a></li><li class="level-2" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_010-http1-1-如何解决-http-的队头阻塞问题" class="sidebar-link reco-side-_010-http1-1-如何解决-http-的队头阻塞问题" data-v-70334359>010: HTTP1.1 如何解决 HTTP 的队头阻塞问题？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#什么是-http-队头阻塞" class="sidebar-link reco-side-什么是-http-队头阻塞" data-v-70334359>什么是 HTTP 队头阻塞？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#并发连接" class="sidebar-link reco-side-并发连接" data-v-70334359>并发连接</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#域名分片" class="sidebar-link reco-side-域名分片" data-v-70334359>域名分片</a></li><li class="level-2" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_011-对-cookie-了解多少" class="sidebar-link reco-side-_011-对-cookie-了解多少" data-v-70334359>011: 对 Cookie 了解多少？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#cookie-简介" class="sidebar-link reco-side-cookie-简介" data-v-70334359>Cookie 简介</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#cookie-属性" class="sidebar-link reco-side-cookie-属性" data-v-70334359>Cookie 属性</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#cookie-的缺点" class="sidebar-link reco-side-cookie-的缺点" data-v-70334359>Cookie 的缺点</a></li><li class="level-2" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_012-如何理解-http-代理" class="sidebar-link reco-side-_012-如何理解-http-代理" data-v-70334359>012: 如何理解 HTTP 代理？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#功能" class="sidebar-link reco-side-功能" data-v-70334359>功能</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#相关头部字段" class="sidebar-link reco-side-相关头部字段" data-v-70334359>相关头部字段</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#x-forwarded-for-产生的问题" class="sidebar-link reco-side-x-forwarded-for-产生的问题" data-v-70334359>X-Forwarded-For 产生的问题</a></li><li class="level-2" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_013-如何理解-http-缓存及缓存代理" class="sidebar-link reco-side-_013-如何理解-http-缓存及缓存代理" data-v-70334359>013: 如何理解 HTTP 缓存及缓存代理？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#为什么产生代理缓存" class="sidebar-link reco-side-为什么产生代理缓存" data-v-70334359>为什么产生代理缓存？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#源服务器的缓存控制" class="sidebar-link reco-side-源服务器的缓存控制" data-v-70334359>源服务器的缓存控制</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#客户端的缓存控制" class="sidebar-link reco-side-客户端的缓存控制" data-v-70334359>客户端的缓存控制</a></li><li class="level-2" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_014-什么是跨域-浏览器如何拦截响应-如何解决" class="sidebar-link reco-side-_014-什么是跨域-浏览器如何拦截响应-如何解决" data-v-70334359>014: 什么是跨域？浏览器如何拦截响应？如何解决？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#什么是跨域" class="sidebar-link reco-side-什么是跨域" data-v-70334359>什么是跨域</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#cors" class="sidebar-link reco-side-cors" data-v-70334359>CORS</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#jsonp" class="sidebar-link reco-side-jsonp" data-v-70334359>JSONP</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#nginx" class="sidebar-link reco-side-nginx" data-v-70334359>Nginx</a></li><li class="level-2" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_015-http-2-有哪些改进" class="sidebar-link reco-side-_015-http-2-有哪些改进" data-v-70334359>015: HTTP/2 有哪些改进？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#头部压缩" class="sidebar-link reco-side-头部压缩" data-v-70334359>头部压缩</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#多路复用" class="sidebar-link reco-side-多路复用" data-v-70334359>多路复用</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#服务器推送" class="sidebar-link reco-side-服务器推送" data-v-70334359>服务器推送</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#总结" class="sidebar-link reco-side-总结" data-v-70334359>总结</a></li><li class="level-2" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#_016-http-2-中的二进制帧是如何设计的" class="sidebar-link reco-side-_016-http-2-中的二进制帧是如何设计的" data-v-70334359>016: HTTP/2 中的二进制帧是如何设计的？</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#帧结构" class="sidebar-link reco-side-帧结构" data-v-70334359>帧结构</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#流的状态变化" class="sidebar-link reco-side-流的状态变化" data-v-70334359>流的状态变化</a></li><li class="level-3" data-v-70334359><a href="/blog/blogs/frontEnd/Note/02.html#流的特性" class="sidebar-link reco-side-流的特性" data-v-70334359>流的特性</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><!----><div></div><canvas id="vuepress-canvas-cursor"></canvas><div class="reco-bgm-panel" data-v-b1d3339e><audio id="bgm" src="https://music.163.com/song/media/outer/url?id=1873321491.mp3" data-v-b1d3339e></audio> <div class="reco-float-box" style="bottom:200px;z-index:999999;display:none;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><img src="https://p2.music.126.net/Uo7OXdK3g4LQdc2hzJ14qQ==/109951166328143737.jpg" data-v-b1d3339e></div> <div class="reco-bgm-box" style="left:10px;bottom:10px;z-index:999999;border-radius:20px;" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="reco-bgm-cover" style="background-image:url(https://p2.music.126.net/Uo7OXdK3g4LQdc2hzJ14qQ==/109951166328143737.jpg);" data-v-b1d3339e><div class="mini-operation" style="display:none;" data-v-b1d3339e><i class="reco-bgm reco-bgm-pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play" style="display:none;" data-v-b1d3339e></i></div> <div class="falut-message" style="display:none;" data-v-b1d3339e>
          播放失败
        </div></div> <div class="reco-bgm-info" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-music music" data-v-b1d3339e></i>WaKe（Live）</div> <div class="info-box" data-v-b1d3339e><i class="reco-bgm reco-bgm-artist" data-v-b1d3339e></i>Hillsong Young &amp; Free</div> <div class="reco-bgm-progress" data-v-b1d3339e><div class="progress-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div> <div class="reco-bgm-operation" data-v-b1d3339e><i class="reco-bgm reco-bgm-last last" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-pause pause" style="display:none;" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-play play" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-next next" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-volume1 volume" data-v-b1d3339e></i> <i class="reco-bgm reco-bgm-mute mute" style="display:none;" data-v-b1d3339e></i> <div class="volume-bar" data-v-b1d3339e><div class="bar" data-v-b1d3339e></div></div></div></div> <div class="reco-bgm-left-box" data-v-b1d3339e data-v-41bcba48 data-v-b1d3339e><i class="reco-bgm reco-bgm-left" data-v-b1d3339e></i></div></div></div><div><div class="sponsor-container" data-v-a142c76a><div class="sponsor-love position-absolute transition-3ms" data-v-a142c76a>
    Sponsor
  </div> <a href="https://github.com/yokefellow/vuepress-plugin-sponsor" target="_blank" title="Github" class="sponsor-github position-absolute transition-3ms" data-v-a142c76a></a> <ul class="sponsor-payment-options transition-3ms" data-v-a142c76a><li id="alipay-option" class="transition-3ms" data-v-a142c76a></li> <li id="wechat-option" class="transition-3ms" data-v-a142c76a></li> <li id="qq-option" class="transition-3ms" data-v-a142c76a></li> <li id="paypal-option" class="transition-3ms" data-v-a142c76a></li></ul> <div class="sponsor-qrcode-container position-absolute" style="display:none;" data-v-a142c76a data-v-a142c76a><div class="sponsor-qrcode-info" style="background-image:url();pointer-events:none;display:none;" data-v-a142c76a data-v-a142c76a></div></div> <div class="sponsor-message position-absolute" style="display:none;" data-v-a142c76a data-v-a142c76a>
      主人忘记设置啦
    </div></div></div><div class="cat-container" data-v-a13867c0><canvas id="vuepress-cat" width="280" height="250" class="live2d" data-v-a13867c0></canvas></div></div></div>
    <script src="/blog/assets/js/app.41200af2.js" defer></script><script src="/blog/assets/js/3.dc4313c1.js" defer></script><script src="/blog/assets/js/1.6ffa0505.js" defer></script><script src="/blog/assets/js/70.67374505.js" defer></script>
  </body>
</html>
