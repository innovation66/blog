(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{653:function(e,v,_){"use strict";_.r(v);var o=_(5),a=Object(o.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h3",{attrs:{id:"对-webpack-的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对-webpack-的理解"}},[e._v("#")]),e._v(" 对 webpack 的理解？")]),e._v(" "),_("p",[_("code",[e._v("webpack")]),e._v(" 是一个用于现代 JavaScript 应用程序的"),_("strong",[e._v("静态模块打包工具")]),e._v("。我们可以使用"),_("code",[e._v("webpack")]),e._v("管理模块。因为在"),_("code",[e._v("webpack")]),e._v("看来，项目中的所有资源皆为模块，通过分析模块间的依赖关系，在其内部构建出一个依赖图，最终编绎输出模块为 HTML、JavaScript、CSS 以及各种静态文件（图片、字体等），让我们的开发过程更加高效。")]),e._v(" "),_("p",[_("code",[e._v("webpack")]),e._v("的主要作用如下：")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("模块打包")]),e._v("。可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。利用打包我们就可以在开发的时候根据我们自己的业务自由划分文件模块，保证项目结构的清晰和可读性。")]),e._v(" "),_("li",[_("code",[e._v("编译兼容")]),e._v("。在前端的“上古时期”，手写一堆浏览器兼容代码一直是令前端工程师头皮发麻的事情，而在今天这个问题被大大的弱化了，通过"),_("code",[e._v("webpack")]),e._v("的"),_("code",[e._v("Loader")]),e._v("机制，不仅仅可以帮助我们对代码做"),_("code",[e._v("polyfill")]),e._v("（polyfill 可以理解为补丁的意思，用于实现浏览器不支持的原生的 api 代码），还可以编译转换诸如"),_("code",[e._v(".less")]),e._v("，"),_("code",[e._v(".vue")]),e._v("，"),_("code",[e._v(".jsx")]),e._v("这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。")]),e._v(" "),_("li",[_("code",[e._v("能力扩展")]),e._v("。通过"),_("code",[e._v("webpack")]),e._v("的"),_("code",[e._v("Plugin")]),e._v("机制，我们在实现"),_("code",[e._v("模块化打包")]),e._v("和"),_("code",[e._v("编译兼容")]),e._v("的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。")])]),e._v(" "),_("h3",{attrs:{id:"webpack-的构建流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#webpack-的构建流程"}},[e._v("#")]),e._v(" webpack 的构建流程？")]),e._v(" "),_("p",[_("code",[e._v("webpack")]),e._v("的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("1、读取"),_("code",[e._v("webpack")]),e._v("的配置参数；加载 Plugin")]),e._v(" "),_("p",[e._v("2、启动"),_("code",[e._v("webpack")]),e._v("，创建"),_("code",[e._v("Compiler")]),e._v("对象并开始解析项目；")]),e._v(" "),_("p",[e._v("3、从入口文件（"),_("code",[e._v("entry")]),e._v("）开始解析，并且找到其导入的依赖模块，递归遍历分析，形成依赖关系树；")]),e._v(" "),_("p",[e._v("4、对不同文件类型的依赖模块使用对应的"),_("code",[e._v("Loader")]),e._v("进行编译，最终转为"),_("code",[e._v("Javascript")]),e._v("文件；")]),e._v(" "),_("p",[e._v("5、整个过程中"),_("code",[e._v("webpack")]),e._v("会通过发布订阅模式，向外抛出一些"),_("code",[e._v("hooks")]),e._v("，而"),_("code",[e._v("webpack")]),e._v("的插件即可通过监听这些关键的事件节点，执行插件任务进而达到干预输出结果的目的。")])])]),e._v(" "),_("ul",[_("li",[e._v("其中文件的解析与构建是一个比较复杂的过程，在"),_("code",[e._v("webpack")]),e._v("源码中主要依赖于"),_("code",[e._v("compiler")]),e._v("和"),_("code",[e._v("compilation")]),e._v("两个核心对象实现。compiler"),_("code",[e._v("对象是一个全局单例，他负责把控整个")]),e._v("webpack"),_("code",[e._v("打包的构建流程。")]),e._v("compilation"),_("code",[e._v("对象是每一次构建的上下文对象，它包含了当次构建所需要的所有信息，每次热更新和重新构建，")]),e._v("compiler"),_("code",[e._v("都会重新生成一个新的")]),e._v("compilation"),_("code",[e._v("对象，负责此次更新的构建过程。而每个模块间的依赖关系，则依赖于")]),e._v("AST"),_("code",[e._v("语法树。每个模块文件在通过")]),e._v("Loader"),_("code",[e._v("解析完成之后，会生成模块代码的")]),e._v("AST 语法树，通过语法树就可以分析这个模块是否还有依赖的模块，进而继续循环执行下一个模块的编译解析。")])]),e._v(" "),_("h3",{attrs:{id:"常见的-loader-有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见的-loader-有哪些"}},[e._v("#")]),e._v(" 常见的 loader 有哪些？")]),e._v(" "),_("p",[e._v("默认情况下，"),_("code",[e._v("webpack")]),e._v("只支持对"),_("code",[e._v("js")]),e._v("和"),_("code",[e._v("json")]),e._v("文件进行打包，但是像"),_("code",[e._v("css")]),e._v("、"),_("code",[e._v("html")]),e._v("、"),_("code",[e._v("png")]),e._v("等其他类型的文件，"),_("code",[e._v("webpack")]),e._v("则无能为力。因此，就需要配置相应的"),_("code",[e._v("loader")]),e._v("进行文件内容的解析转换。")]),e._v(" "),_("p",[_("code",[e._v("image-loader")]),e._v("：加载并且压缩图片文件。"),_("code",[e._v("less-loader")]),e._v("： 加载并编译 LESS 文件。"),_("code",[e._v("sass-loader")]),e._v("：加载并编译 SASS/SCSS 文件。"),_("code",[e._v("css-loader")]),e._v("：加载 CSS，支持模块化、压缩、文件导入等特性，使用"),_("code",[e._v("css-loader")]),e._v("必须要配合使用"),_("code",[e._v("style-loader")]),e._v("。"),_("code",[e._v("style-loader")]),e._v("：用于将 CSS 编译完成的样式，挂载到页面的 style 标签上。需要注意 "),_("code",[e._v("loader")]),e._v(" 执行顺序，"),_("code",[e._v("style-loader")]),e._v(" 要放在第一位，"),_("code",[e._v("loader")]),e._v(" 都是从后往前执行。"),_("code",[e._v("babel-loader")]),e._v("：把 ES6 转换成 ES5"),_("code",[e._v("postcss-loader")]),e._v("：扩展 CSS 语法，使用下一代 CSS，可以配合 "),_("code",[e._v("autoprefixer")]),e._v(" 插件自动补齐 CSS3 前缀。"),_("code",[e._v("eslint-loader")]),e._v("：通过 ESLint 检查 JavaScript 代码。"),_("code",[e._v("vue-loader")]),e._v("：加载并编译 Vue 组件。"),_("code",[e._v("file-loader")]),e._v("：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)"),_("code",[e._v("url-loader")]),e._v("：与 "),_("code",[e._v("file-loader")]),e._v(" 类似，区别是用户可以设置一个阈值，大于阈值会交给 "),_("code",[e._v("file-loader")]),e._v(" 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)")]),e._v(" "),_("h2",{attrs:{id:"有哪些常见的-plugin-你用过哪些-plugin"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#有哪些常见的-plugin-你用过哪些-plugin"}},[e._v("#")]),e._v(" 有哪些常见的 Plugin？你用过哪些 Plugin？")]),e._v(" "),_("p",[_("code",[e._v("ignore-plugin")]),e._v("：忽略部分文件"),_("code",[e._v("html-webpack-plugin")]),e._v("：简化 HTML 文件创建 (依赖于 html-loader)")]),e._v(" "),_("p",[_("code",[e._v("mini-css-extract-plugin")]),e._v(": 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代 extract-text-webpack-plugin)"),_("code",[e._v("uglifyjs-webpack-plugin")]),e._v("：不支持 ES6 压缩 (Webpack4 以前)"),_("code",[e._v("terser-webpack-plugin")]),e._v(": 支持压缩 ES6 (Webpack4)"),_("code",[e._v("webpack-parallel-uglify-plugin")]),e._v(": 多进程执行代码压缩，提升构建速度"),_("code",[e._v("clean-webpack-plugin")]),e._v(": 目录清理"),_("code",[e._v("webpack-bundle-analyzer")]),e._v(": 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)")]),e._v(" "),_("h3",{attrs:{id:"loader-和-plugin-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#loader-和-plugin-的区别"}},[e._v("#")]),e._v(" loader 和 plugin 的区别？")]),e._v(" "),_("p",[_("code",[e._v("Loader")]),e._v(" 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。"),_("code",[e._v("Plugin")]),e._v(" 就是插件，基于事件流框架 "),_("code",[e._v("Tapable")]),e._v("，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。")]),e._v(" "),_("p",[_("code",[e._v("Loader")]),e._v(" 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。"),_("code",[e._v("Plugin")]),e._v(" 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。")]),e._v(" "),_("h2",{attrs:{id:"使用-webpack-开发时-你用过哪些可以提高效率的插件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用-webpack-开发时-你用过哪些可以提高效率的插件"}},[e._v("#")]),e._v(" 使用 webpack 开发时，你用过哪些可以提高效率的插件？")]),e._v(" "),_("p",[e._v("(这道题还蛮注重实际，用户的体验还是要从小抓起的)")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("webpack-dashboard")]),e._v("：可以更友好的展示相关打包信息。")]),e._v(" "),_("li",[_("code",[e._v("webpack-merge")]),e._v("：提取公共配置，减少重复配置代码")]),e._v(" "),_("li",[_("code",[e._v("speed-measure-webpack-plugin")]),e._v("：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。")]),e._v(" "),_("li",[_("code",[e._v("size-plugin")]),e._v("：监控资源体积变化，尽早发现问题")]),e._v(" "),_("li",[_("code",[e._v("HotModuleReplacementPlugin")]),e._v("：模块热替换")])]),e._v(" "),_("h2",{attrs:{id:"source-map-是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#source-map-是什么"}},[e._v("#")]),e._v(" source map 是什么")]),e._v(" "),_("p",[_("code",[e._v("source map")]),e._v(" 是将编译、打包、压缩后的代码映射回源代码的过程。打包压缩后的代码不具备良好的可读性，想要调试源码就需要 soucre map。map 文件只要不打开开发者工具，浏览器是不会加载的。有了这份映射文件，我们只需要在我们的压缩代码的最末端加上这句注释，即可让 sourceMap 生效：//# sourceURL=/path/to/file.js.map。有了这段注释后，浏览器就会通过"),_("code",[e._v("sourceURL")]),e._v("去获取这份映射文件，通过解释器解析后，实现源码和混淆代码之间的映射。因此 sourceMap 其实也是一项需要浏览器支持的技术。如果我们仔细查看 webpack 打包出来的 bundle 文件，就可以发现在默认的"),_("code",[e._v("development")]),e._v("开发模式下，每个"),_("code",[e._v("_webpack_modules__")]),e._v("文件模块的代码最末端，都会加上"),_("code",[e._v("//# sourceURL=webpack://file-path?")]),e._v("，从而实现对 sourceMap 的支持。")]),e._v(" "),_("h3",{attrs:{id:"webpack-的热更新原理是"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#webpack-的热更新原理是"}},[e._v("#")]),e._v(" webpack 的热更新原理是？")]),e._v(" "),_("p",[_("code",[e._v("模块热替换(HMR - hot module replacement)")]),e._v("，又叫做"),_("code",[e._v("热更新")]),e._v("，在不需要刷新整个页面的同时更新模块，能够提升开发的效率和体验。热更新时只会局部刷新页面上发生了变化的模块，同时可以保留当前页面的状态，比如复选框的选中状态等。")]),e._v(" "),_("p",[e._v("热更新的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上"),_("code",[e._v("webpack-dev-server")]),e._v("与浏览器之间维护了一个"),_("code",[e._v("websocket")]),e._v("，当本地资源发生变化时，"),_("code",[e._v("webpack-dev-server")]),e._v("会向浏览器推送更新，并带上构建时的"),_("code",[e._v("hash")]),e._v("，让客户端与上一次资源进行对比。客户端对比出差异后会向"),_("code",[e._v("webpack-dev-server")]),e._v("发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向"),_("code",[e._v("webpack-dev-server")]),e._v("发起 （jsonp） 请求获取该"),_("code",[e._v("chunk")]),e._v("的增量更新。")]),e._v(" "),_("p",[e._v("后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由"),_("code",[e._v("HotModulePlugin")]),e._v(" 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像"),_("code",[e._v("react-hot-loader")]),e._v("和"),_("code",[e._v("vue-loader")]),e._v("都是借助这些 API 实现热更新")]),e._v(" "),_("h2",{attrs:{id:"如何对-bundle-体积进行监控和分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何对-bundle-体积进行监控和分析"}},[e._v("#")]),e._v(" 如何对 bundle 体积进行监控和分析？")]),e._v(" "),_("p",[_("code",[e._v("VSCode")]),e._v(" 中有一个插件 "),_("code",[e._v("Import Cost")]),e._v(" 可以帮助我们对引入模块的大小进行实时监测，还可以使用 "),_("code",[e._v("webpack-bundle-analyzer")]),e._v(" 生成 "),_("code",[e._v("bundle")]),e._v(" 的模块组成图，显示所占体积。"),_("code",[e._v("bundlesize")]),e._v(" 工具包可以进行自动化资源体积监控。")]),e._v(" "),_("h2",{attrs:{id:"聊一聊-babel-原理吧"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#聊一聊-babel-原理吧"}},[e._v("#")]),e._v(" 聊一聊 Babel 原理吧")]),e._v(" "),_("p",[e._v("Babel 是一个 JavaScript 编译器，是一个工具链，主要用于将采用 ECMAScript 2015+ 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。"),_("strong",[e._v("解析（Parse）")]),e._v(" ：将源代码转换成更加抽象的表示方法（例如抽象语法树）。包括词法分析和语法分析。词法分析主要把字符流源代码（Char Stream）转换成令牌流（ Token Stream），语法分析主要是将令牌流转换成抽象语法树（Abstract Syntax Tree，AST）。"),_("strong",[e._v("转换（Transform）")]),e._v(" ：通过 Babel 的插件能力，对（抽象语法树）做一些特殊处理，将高版本语法的 AST 转换成支持低版本语法的 AST。让它符合编译器的期望，当然在此过程中也可以对 AST 的 Node 节点进行优化操作，比如添加、更新以及移除节点等。"),_("strong",[e._v("生成（Generate）")]),e._v(" ：将 AST 转换成字符串形式的低版本代码，同时也能创建 Source Map 映射。")]),e._v(" "),_("h3",{attrs:{id:"如何提高-webpack-的构建速度"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何提高-webpack-的构建速度"}},[e._v("#")]),e._v(" 如何提高 webpack 的构建速度？")]),e._v(" "),_("ol",[_("li",[e._v("代码压缩\n"),_("ul",[_("li",[e._v("JS 压缩"),_("code",[e._v("webpack 4.0")]),e._v("默认在生产环境的时候是支持代码压缩的，即"),_("code",[e._v("mode=production")]),e._v("模式下。 实际上"),_("code",[e._v("webpack 4.0")]),e._v("默认是使用"),_("code",[e._v("terser-webpack-plugin")]),e._v("这个压缩插件，在此之前是使用 "),_("code",[e._v("uglifyjs-webpack-plugin")]),e._v("，两者的区别是后者对 ES6 的压缩不是很好，同时我们可以开启 "),_("code",[e._v("parallel")]),e._v("参数，使用多进程压缩，加快压缩。")]),e._v(" "),_("li",[e._v("CSS 压缩 通过 mini-css-extract-plugin 提取 Chunk 中的 CSS 代码到单独文件，CSS 压缩通常是去除无用的空格等，因为很难去修改选择器、属性的名称、值等。可以使用另外一个插件："),_("code",[e._v("css-minimizer-webpack-plugin")]),e._v("。")]),e._v(" "),_("li",[e._v("HTML 压缩使用 HtmlWebpackPlugin 插件来生成 HTML 的模板时候，通过配置属性 minify 进行 html 优化。")])])]),e._v(" "),_("li",[e._v("图片压缩 配置"),_("code",[e._v("image-webpack-loader")])]),e._v(" "),_("li",[e._v("Tree Shaking\n"),_("code",[e._v("Tree Shaking")]),e._v("先收集模块导出信息内容 然后进行标记 用到值放到 webpack 导出对象中 没用的直接删除，依赖于 ES Module 的静态语法分析（webpack4）Webpack 5 中增加了对一些 CommonJS 风格模块代码的静态分析功功能。 在"),_("code",[e._v("webpack")]),e._v("实现"),_("code",[e._v("Tree shaking")]),e._v("有两种方案：\n"),_("ul",[_("li",[e._v("usedExports：通过标记某些函数是否被使用，之后通过 Terser 来进行优化的，在配置文件 modele 的 optimization 中配置 usedExports，使用之后，没被用上的代码在 webpack 打包中会加入 unused harmony export mul 注释，用来告知 Terser 在优化时，可以删除掉这段代码。")]),e._v(" "),_("li",[e._v("sideEffects：跳过整个模块/文件，直接查看该文件是否有副作用 .sideEffects 用于告知 webpack compiler 哪些模块时有副作用，配置方法是在 package.json 中设置 sideEffects 属性 如果设置为"),_("code",[e._v("false")]),e._v("，就是告知"),_("code",[e._v("webpack")]),e._v("可以安全的删除未用到的"),_("code",[e._v("exports")]),e._v("。如果有些文件需要保留，可以设置为数组的形式")])])]),e._v(" "),_("li",[e._v("缩小打包域 1.排除"),_("code",[e._v("webpack")]),e._v("不需要解析的模块，即在使用"),_("code",[e._v("loader")]),e._v("的时候，在尽量少的模块中去使用。可以借助 "),_("code",[e._v("include")]),e._v("和"),_("code",[e._v("exclude")]),e._v("这两个参数，规定"),_("code",[e._v("loader")]),e._v("只在那些模块应用和在哪些模块不应用。 2. 在 resolve.modules 配置中 指明第三方模块的绝对路径 (减少不必要的查找) 3.在 resove.extensions 配置中尽可能减少后缀尝试的可能性.resolve.alias 则是给路径设置别名，作用是用别名代替前面的路径，不是省略，而是用别名代替前面的长路径 4.用 IgnorePlugin 忽略无用文件 5.noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)")]),e._v(" "),_("li",[e._v("减少 ES6 转为 ES5 的冗余代码\n使用"),_("code",[e._v("bable-plugin-transform-runtime")]),e._v("插件")]),e._v(" "),_("li",[e._v("提取公共代码\n通过配置"),_("code",[e._v("CommonsChunkPlugin")]),e._v("插件，将多个页面的公共代码抽离成单独的文件,已经被 SplitChunksPlugin 替代")]),e._v(" "),_("li",[e._v("使用 webpack.DllPlugin 来预先编译和打包不会变动存在的文件，在业务代码中直接引入，可以加快 Webpack 编译打包的速度，但是并不能减少最后生成的代码体积。")]),e._v(" "),_("li",[_("code",[e._v("充分利用缓存提升二次构建速度")]),e._v("：babel-loader 开启缓存 terser-webpack-plugin 开启缓存")])]),e._v(" "),_("h3",{attrs:{id:"是否写过-plugin-简单描述一下编写-plugin-的思路"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#是否写过-plugin-简单描述一下编写-plugin-的思路"}},[e._v("#")]),e._v(" 是否写过 Plugin？简单描述一下编写 plugin 的思路？")]),e._v(" "),_("p",[_("code",[e._v("webpack")]),e._v("基于发布订阅模式，在运行的生命周期中会广播出许多事件，插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务，从而实现自己想要的功能。既然基于发布订阅模式，那么知道"),_("code",[e._v("Webpack")]),e._v("到底提供了哪些事件钩子供插件开发者使用是非常重要的，上文提到过"),_("code",[e._v("compiler")]),e._v("和"),_("code",[e._v("compilation")]),e._v("是"),_("code",[e._v("Webpack")]),e._v("两个非常核心的对象，其中"),_("code",[e._v("compiler")]),e._v("暴露了和 "),_("code",[e._v("Webpack")]),e._v("整个生命周期相关的钩子（"),_("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompiler-hooks%2F",target:"_blank",rel:"noopener noreferrer"}},[e._v("compiler-hooks"),_("OutboundLink")],1),e._v("），而"),_("code",[e._v("compilation")]),e._v("则暴露了与模块和依赖有关的粒度更小的事件钩子（"),_("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompilation-hooks%2F",target:"_blank",rel:"noopener noreferrer"}},[e._v("Compilation Hooks"),_("OutboundLink")],1),e._v("）。规范和原则：")]),e._v(" "),_("ul",[_("li",[e._v("插件必须是一个函数或者是一个包含 "),_("code",[e._v("apply")]),e._v(" 方法的对象，这样才能访问"),_("code",[e._v("compiler")]),e._v("实例；")]),e._v(" "),_("li",[e._v("传给每个插件的 "),_("code",[e._v("compiler")]),e._v(" 和 "),_("code",[e._v("compilation")]),e._v(" 对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件;")]),e._v(" "),_("li",[e._v("异步的事件需要在插件处理完任务时调用回调函数通知 "),_("code",[e._v("Webpack")]),e._v(" 进入下一个流程，不然会卡住;")])])])}),[],!1,null,null,null);v.default=a.exports}}]);